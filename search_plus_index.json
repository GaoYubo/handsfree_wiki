{"contribute.html":{"url":"contribute.html","title":"contribute","keywords":"","body":"如何贡献文档 docs　目录用于存放md文件 images　目录用于存放md引用的图片 docs/Tutorial/Advanced　下的文章独立性比较高，图片和md可以放在同目录 在Github上fork　作者的HandsFree Wiki源文件 : https://github.com/mawenke/handsfree_wiki 在自己的本地仓库上编辑更改文档后用Github　的Pull Requests功能提交改动给作者． Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-08 16:29:20 "},"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架,以优秀的嵌入式系统框架为核心,精良的电路、机械设计为支撑,帮您快速实现多种形态的机器人。本系统包含机器人导航,SLAM,计算机视觉等模块,并拥有自己上层软件和调试系统。她支持国外其他的开源项目,如 ROS, MPRT, PIXHAWK 等,这一切都为您带来了无比的便捷和快乐! HandsFree 2017 社区建设 HandsFree Github HandsFree Website 社区交流群: 521037187 (Hands Free Community) 联系邮箱： hands_free@126.com 目前已有国内五十多家高校、科研机构采用HandsFree 开源系统 资源索引 HandsFree百度云资料整理 西北工业大学布树辉教授个人网站 RosClub Exbot 易科实验室 产品介绍 HandsFree 拥有系统完整的软硬件产品，使您更加便捷的进行机器人应用的开发 购买地址：淘宝店铺 机器人 Mini Stone Giraffe 周边产品 HandsFree Mini 机器人平台 外形及性能参数 机器人参数 值 空重 直径(cm) 23 高度(cm) 20.4（不加云台） 33.3（加云台） 最大速度(m/s) 1.2 额定承载能力(kg) 3 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的控制器 TK1，RK3288，树莓派，pcduino 套餐价格　　　　　　　　　　　　　　　 Mini 套餐 属性(默认亚克力材质，玻璃纤维 + 100RMB) 价格(不带发票) 基础版 1.机械结构2.控制电路，驱动电路，配套开发调试硬件，电池x13.技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 1899 RMB +100 (升级为玻纤) 导航开发版(推荐) 1.基础版全部内容2.TK1，rplidar a1(激光雷达) 4499 RMB+100 (升级为玻纤) 视觉开发版 1.基础版全部内容2.TK1，rplidar a1(激光雷达)3.华硕Xtion2摄像头 6499 RMB+100 (升级为玻纤) 定制版 1.量大可定制2.任选可支持的传感器，设备，控制器3.可定制相关服务，如系统配置，RoboCup比赛指导4.定制 导航/任务执行/人脸识别/目标识别/跟踪/机械臂抓取 等功能 ¥¥¥¥¥ RMB 点击购买 Mini　　 　　　　　　　　Mini 详细信息 HandsFree Stone 机器人平台 外形及性能参数 机器人参数 值 空重 约3kg 直径(cm) 36 高度(cm) 32.2（不加云台） 125.2（加云台） 最大速度(m/s) 1.2 额定承载能力(kg) 6 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的设备 Dobot机械臂 1/2，HF云台，双目摄像头，单目高清摄像头 支持的控制器 TX1，TK1，RK3288，树莓派，pcduino 套餐价格　 Stone 套餐 属性 价格(不带发票) 基础版 1.机械结构(玻纤材质，不包含云台)2.控制电路，驱动电路，配套开发调试硬件，电池x13.技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 2999 RMB 导航开发版 1.基础版全部内容2.TK1，rplidar a1(激光雷达) 5599 RMB 视觉开发版(推荐) 1.基础版全部内容2.TK1，rplidar a1(激光雷达)3.华硕Xtion2摄像头，云台 8199 RMB 豪华开发版 1.基础版全部内容2.TK1，rplidar a2(a1雷达升级版)3.华硕Xtion2摄像头，云台 9999 RMB 定制版 1.量大可定制2.任选可支持的传感器，设备，控制器3.可定制相关服务，如系统配置，RoboCup比赛指导4.定制 导航/任务执行/人脸识别/目标识别/跟踪/机械臂抓取 等功能 ¥¥¥¥¥ RMB 点击购买 Stone　　 　　　　　　　　Stone 详细信息 HandsFree Giraffe 机器人平台 外形及性能参数 机器人参数 值 空重 直径(cm) 38 高度(cm) 33.2（不加云台） 126.2（加云台） 最大速度(m/s) 1.6 额定承载能力(kg) 30 kg 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的设备 HandFree arm，Dobot机械臂 1/2，HF云台，双目摄像头，单目高清摄像头 支持的控制器 笔记本，TX1，TK1，RK3288，树莓派，pcduino 套餐价格　购买 Giraffe 套餐 属性 价格(不带发票) 基础版 1.机械结构(底盘 + 云台，不含机械臂)2.控制电路，驱动电路，开发调试硬件，电池套装x33.技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 9999 RMB 开发者版 1.基础版全部内容2.TK1，rplidar a2(a1雷达升级版)3.华硕Xtion2摄像头，云台4.备用配件：驱动x2,电机x1,线材若干5.可提供RobotCup，RoboMasters等比赛的指导 19999 RMB 定制版 1.量大可定制2.任选可支持的传感器，设备，控制器3.可定制相关服务，如系统配置，RoboCup比赛指导4.定制 导航/任务执行/人脸识别/目标识别/跟踪/机械臂抓取 等功能 ¥¥¥¥¥ RMB 定制机械臂 1.HandsFree 机械臂2.升降台 100000 RMB 点击购买 Giraffe　　 　　　　　 　Giraffe 详细信息 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-30 13:12:52 "},"docs/About/":{"url":"docs/About/","title":"About","keywords":"","body":"Overview HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架,以优秀的嵌入式系统框架为核心,精良的电路、机械设计为支撑,帮您快速实现多种形态的机器人。本系统包含机器人导航,SLAM,计算机视觉等模块,并拥有自己上层软件和调试系统。她支持国外其他的开源项目,如 ROS, MPRT, PIXHAWK 等,这一切都为您带来了无比的便捷和快乐! HandsFree 2017 社区建设 HandsFree Github HandsFree Website HandsFree Website 社区交流群: 521037187 (Hands Free Community) 联系邮箱： hands_free@126.com 目前已有国内五十多家高校、科研机构采用HandsFree 开源系统 资源索引 HandsFree百度云资料整理 西北工业大学布树辉教授个人网站 RosClub Exbot 易科实验室 产品介绍 HandsFree 拥有系统完整的软硬件产品，使您更加便捷的进行机器人应用的开发 购买地址：淘宝店铺 机器人 Mini Stone Giraffe 周边产品 HandsFree Mini 机器人平台 外形及性能参数 机器人参数 值 空重 直径(cm) 23 高度(cm) 20.4（不加云台） 33.3（加云台） 最大速度(m/s) 1.2 额定承载能力(kg) 3 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的控制器 TK1，RK3288，树莓派，pcduino 套餐价格　　　　　　　　　　　　　　　 Mini 套餐 属性(默认亚克力材质，玻璃纤维 + 100RMB) 价格(不带发票) 基础版 1.机械结构2.控制电路，驱动电路，配套开发调试硬件，电池x13.技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 1899 RMB +100 (升级为玻纤) 导航开发版(推荐) 1.基础版全部内容2.TK1，rplidar a1(激光雷达) 4499 RMB+100 (升级为玻纤) 视觉开发版 1.基础版全部内容2.TK1，rplidar a1(激光雷达)3.华硕Xtion2摄像头 6499 RMB+100 (升级为玻纤) 定制版 1.量大可定制2.任选可支持的传感器，设备，控制器3.可定制相关服务，如系统配置，RoboCup比赛指导4.定制 导航/任务执行/人脸识别/目标识别/跟踪/机械臂抓取 等功能 ¥¥¥¥¥ RMB 点击购买 Mini　　 　　　　　　　　Mini 详细信息 HandsFree Stone 机器人平台 外形及性能参数 机器人参数 值 空重 约3kg 直径(cm) 36 高度(cm) 32.2（不加云台） 125.2（加云台） 最大速度(m/s) 1.2 额定承载能力(kg) 6 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的设备 Dobot机械臂 1/2，HF云台，双目摄像头，单目高清摄像头 支持的控制器 TX1，TK1，RK3288，树莓派，pcduino 套餐价格　 Stone 套餐 属性 价格(不带发票) 基础版 1.机械结构(玻纤材质，不包含云台)2.控制电路，驱动电路，配套开发调试硬件，电池x13.技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 2999 RMB 导航开发版 1.基础版全部内容2.TK1，rplidar a1(激光雷达) 5599 RMB 视觉开发版(推荐) 1.基础版全部内容2.TK1，rplidar a1(激光雷达)3.华硕Xtion2摄像头，云台 8199 RMB 豪华开发版 1.基础版全部内容2.TK1，rplidar a2(a1雷达升级版)3.华硕Xtion2摄像头，云台 9999 RMB 定制版 1.量大可定制2.任选可支持的传感器，设备，控制器3.可定制相关服务，如系统配置，RoboCup比赛指导4.定制 导航/任务执行/人脸识别/目标识别/跟踪/机械臂抓取 等功能 ¥¥¥¥¥ RMB 点击购买 Stone　　 　　　　　　　　Stone 详细信息 HandsFree Giraffe 机器人平台 外形及性能参数 机器人参数 值 空重 直径(cm) 38 高度(cm) 33.2（不加云台） 126.2（加云台） 最大速度(m/s) 1.6 额定承载能力(kg) 30 kg 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的设备 HandFree arm，Dobot机械臂 1/2，HF云台，双目摄像头，单目高清摄像头 支持的控制器 笔记本，TX1，TK1，RK3288，树莓派，pcduino 套餐价格　购买 Giraffe 套餐 属性 价格(不带发票) 基础版 1.机械结构(底盘 + 云台，不含机械臂)2.控制电路，驱动电路，开发调试硬件，电池套装x33.技术手册，社区支持，技术交流和指导 (不提供免费教学培训) 9999 RMB 开发者版 1.基础版全部内容2.TK1，rplidar a2(a1雷达升级版)3.华硕Xtion2摄像头，云台4.备用配件：驱动x2,电机x1,线材若干5.可提供RobotCup，RoboMasters等比赛的指导 19999 RMB 定制版 1.量大可定制2.任选可支持的传感器，设备，控制器3.可定制相关服务，如系统配置，RoboCup比赛指导4.定制 导航/任务执行/人脸识别/目标识别/跟踪/机械臂抓取 等功能 ¥¥¥¥¥ RMB 定制机械臂 1.HandsFree 机械臂2.升降台 100000 RMB 点击购买 Giraffe　　 　　　　　 　Giraffe 详细信息 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-02 10:30:05 "},"docs/About/HandsFree.html":{"url":"docs/About/HandsFree.html","title":"HandsFree","keywords":"","body":"概述 当你热爱某种事物，你可能会想办法去弥补它身上的缺点，即使意味着会牺牲你一点点，我们只是一群呆在大学里幼稚青年，但我们也有着对机器人事业的向往。 HandsFree， 顾名思义解放双手。 我们想做到的是能够搭建一个共享的平台，一个友好的易于共同开发的框架。HandsFree 从嵌入式平台开始，逐步地扩展到了相应的其他周边，为的是让整个机器人的开发过程降低耦合，尽可能地减少一些底层的开发环节，在开发过程中提供了一个更好的交流方式。HandsFree 其理念核心是优化开发过程的同时，让设计的 idea 的分享过程更加 Free，是乐于分享的，鼓励分享的。 HandsFree Team 是一个乐于奉献于机器人事业的团队，我们希望能为每一个走进机器人世界的学者带来便利。HandsFree 理念总结成一句话：创造一个机会共同成长。 如果你觉得不错的话，就一起加入进来吧！！！ 理念： 探索，成长，分享 宗旨： 以学习和科研为第一要义，对知识和技术的追求永无止境，不断创新，精益求精，提升自我； 其次，尽能力承担一定的社会责任，重视分享； 最后，鼓励创造社会价值和财富以维持长期发展。 内容： HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架， 以优秀的嵌入式系统框架为核心， 精良的电路、 机械设计为支撑，帮您快速实现多种形态的机器人。本系统包含机器人导航，SLAM，计算机视觉等模块， 并拥有自己上层软件和调试系统。 她支持国外其他的开源项目， 如 ROS,MPRT, PIXHAWK 等，这一切都为您带来了无比的便捷和快乐！ 现状： HandsFree 是一个机器人开源项目，涵盖了和机器人相关的许多方面。我们面向开源的主要任务是搭建一个机器人系统， 并且尽可能使用各种工具来实现目的。 HandsFree 人员由 HandsFree Team ， HandsFree Community 组成。 HandsFree Team 是 HandsFree 的缔造者和主要开发人员，负责更新，管理，建设 HandsFree 开源社区。目前 HandsFree 团队主要是由西北工业大学，厦门大学等几所大学的学生或者实验室组成。 HandsFreeCommunity ，指所有参与，使用该开源项目的伙伴构建的交流圈。 我们希望能有志同道合的人加入我们，一起学习交流。 HandsFree 组成 项目虽然看起来涉及很广，但目前主要任务大概有三个。 一 OpenRE 库 全称 Open Source Robot Embedded Library，也就是机器人嵌入式库。简单的说，其作用与国外知名的无人机开发架构 pixhawk 类似，只不过 pixhwak 主要是面向飞行器，而 OpenRE 则是面向多模态机器人的。 Download OpenRE 二 多模态平台设计 我们的开发项目和开发平台是多样化的，比如二轮，三轮的移动机器人，四旋翼固定翼飞行器等，重复造轮子的问题是机器人学者和创业者最常遇到的问题，好的系统是要求很好的泛性的，能够适应大部分平台，避免了重复劳动的弊端，这就要求我们的产品更加多元化。 在多模态机器人平台搭建方面，研究的主要内容是设计精良的机械和电路系统。机械系统包括各种模型的机器人躯体、机械臂、云台等。电路则包含控制系统，驱动电路，电源管理系统，硬件调试等方面。 多模态平台旨在以机器人学，自动化，通信电子和周边知识为支撑，搭建科学、鲁棒、友好、统一的机器人硬件系统，以配合整个软硬件系统的统一 为了促进社区交流，我们开源了大部分的设计资料，请看百度云 三 系统搭建 主要是基于前两个任务，结合团队在 SLAM， 物体识别，机器人任务规划等研究，以及国外知名的 ROS 等开源项目，搭建整个机器人系统，实现一些应用。 自主移动模块框架搭建 物体识别模块 机械臂控制模块 多机器人协同 HandsFree Github 总结 我们希望HandsFree 成为一套可以遵循的标准，而不仅仅只是一个工程，所以我们精心制定了电路设计标准和机械设计标准，并且公开了我们团队的PCBLIB和机械模型库，凡是照着这个标准来设计的机器人将会很大程度的兼容HandsFree的软件系统，我们希望此举让更多的机器人研究者得到便利，也希望有心人帮助我们完善这个标准的内容。 PIL 介绍 西北工业大学布树辉教授的智能系统实验室开发的跨平台软件库 PIL，支持多线程、时钟、插件、网络、常用硬件抽象、计算机视觉、GUI等功能。布老师是我人生中最敬佩导师，他不仅有着超强的工程和科研能力，而且和蔼可亲，亦师亦友，手把手教，更难得的是，他比学生们还要努力，总是走在团队的最前面带着每个学生奋斗，喜欢机器人或者无人机领域的伙伴们可以关注一下他的个人网站，如果想读他研究生或者博士的伙伴也可以来联系群主。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 17:09:27 "},"docs/About/Project-Overview.html":{"url":"docs/About/Project-Overview.html","title":"Project Overview","keywords":"","body":"开源机器人项目 Hands Free 综合介绍 ppt source file download : HandsFree_Introduction Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 16:43:29 "},"docs/About/Why-HandsFree.html":{"url":"docs/About/Why-HandsFree.html","title":"Why HandsFree","keywords":"","body":"社区人士对HansFree的评价 西北工业大学 布树辉教授 Northwestern Polytechnical UniversityYouyi west road #127, Xi'an 710072, Chinae-mail: bushuhui@nwpu.edu.cnhomepage: http://www.adv-ci.com 我们正处在一个人工智能大变革的时代，高智能的软件、机器人越来越多的出现在我们的生活中，在这波浪潮中我们要怎么应对？我觉得大家无可避免的面对了一个非常巨大的挑战和机遇，机器人作为人工智能的载体必将在未来起到越来越重要的作用。未来的20年，我们所处的世界必将发生巨大的变化，所以我们必须面对这样的变化，不管你的专业是什么，其实都与机器人有或多或少的关系。为了更好的学习机器人技术，如果有一套设计精良的机器人平台将会极大加快学习、研究的速度。HandsFree是一个非常优秀的开源机器人平台，使用这个平台可以让你很快就构建一个机器人系统，得益于优秀的架构设计，能够支持多种形态的机器人形态，利用自主开发的开源OpenRE机器人中间件，能够极大的降低机器人程序开发的难度。 HandsFree创始人是西工大机器人基地的马文科，他是我见过学生中最有追求、最有理想的学生，和他共同工作的一年中，我深深受到了他那种坚韧不拔、努力学习的感染。受到他的感染，目前HandsFree吸引了20多个成员围绕机械、硬件、软件、算法开展学习、研究工作。他们通过无私的工作在为机器人事业奉献自己的力量，他们身上体现了机器人基地培养出来同学对机器人事业的热爱，看到中国机器人事业发展壮大的希望。他们做出的成果都通过开源的形式共享给大家，能够深切的感受到他们愿意从自身开始，为推动中国机器人开源平台事业向前发展的愿景。 Hands Free是一个乐于奉献于机器人事业的团队，希望能为每一个走进机器人世界的爱好者带来便利。Hands Free 理念是：探索，成长，分享，创造一个机会共同成长。如果觉得不错，就一起加入HandsFree的大家庭吧，保证你会在这里得到能力的提升！ 张瑞雷 (zhangrelay) 张瑞雷，在高校从事多机器人系统仿真和编队控制研究与教学工作，Exbot机器人实验室成员，ROS星火计划讲师，热衷于机器人和人工智能前沿技术的教学和传播，希望能为国内开源机器人社区贡献自己一份力量。 易科机器人(Exbot)成员 : http://blog.exbot.net/个人博客 ： http://my.csdn.net/ZhangRelay优酷： http://i.youku.com/zhangrelay翻译书籍： ROS机器人程序设计（原书第2版） 自从接触并学习研究机器人系统这10多年过程中，一直在寻找一款上手简易，功能丰富，定制灵活，扩展性强的机器人平台。不仅出于自己测试算法的需要，也是为了方便相关方法的推广和教学，在这期间，不经意间发现了HardsFree。其实我觉得这款平台最大的优势也就是解放双手，不需要自己搭建电路，设计模具等，从而实现了Mind-Creative，让我可以更多的去关注机器人的大脑，即算法的开发与测试。这是一款简约不简单ROS机器人平台，值得拥有。 田博（贾子枫） 南京天之博特机器人科技有限公司创始人, ROS星火计划讲师博客：http://tianb03.blogspot.com/知乎：https://www.zhihu.com/people/tianb03/ROS机器人培训与就业请关注微信公众号：天之博特（tianzhibote） HandsFree 每次在ROS的课程上我都会讲到，我们取之于开源，却少有人回馈开源。很多研究单位做一点小小的改进都敝帚自珍，这对于机器人行业在国内的发展是极为不利的，长此以往，讲什么赶超美国日本欧洲都是空谈！终于，我们盼到了Handsfree，国内机器人开源社区的一股清流，软硬件全部开源，而且研发团队也是国内一流！虽然比起老牌的Pioneer，Turtlebot等平台，Handsfree还略显稚嫩，但是他们在中文学习资源、社区以及软件配套上，都是其他平台无法比拟的，已有国内机器人开源平台执牛耳者的风范。希望大家能够关心HandsFree，支持HandsFree，共建开源机器人大社区，推动我国的移动机器人的人才培养、技术水平以及产业发展！ 刘昌祥 原2011届西工大舞蹈机器人基地家政视觉组成员 对于我们这种机械和电子都很苦手的程序员来说，有一个容易上手并且好用的平台，可以节省大量的不必要的时间。HandsFree给我提供了这种便利。设计贴心，组装简单易懂，核心板的排线开始比较难插（第一代），但是掌握技巧以后就很容易组装了。我应该是最早订购HF的那批，拿到的是初代HF原型机（后来才知道那个黄色的膜其实可以撕掉，撕掉以后就变成晶莹剔透，立马又高大上几个档次），尽管是初代，已经可以体会到是研发团队的心血之作。HF的机器帮助我完成了很多实验的验证，包括RL引导的机器人避障行为研究等，在最初选择的时候我也考虑过turtlrbot这些常用的机器人平台，但是HF以它极高的性价比打动了我。选择HF，是最正确的选择。 雷一鸣 我叫雷一鸣，是一名热爱机器人的大四老油条，来自武汉的一所普通一本院校。我在14年的时候就接触到 ROS 和 TurtleBot2 ，在校期间担任学院机器人队的学生负责人，主要负责学生竞赛和自主机器人开发等。自主开发机器人博客移步 -> http://leiym.com/2016/05/05/tank1/ 简而言之，HandsFree 是一套完全开源的基于ROS的自主导航轮式机器人平台。首先相对于 TurtleBot2 只开源了上位机程序，并没有开源底层源码的半开源，HandsFree 不仅开源了底层控制板程序，甚至连控制板的硬件部分都开源出来，免费地提供给爱好者DIY。其次， HandsFree 通信层基于 ros_controller 开发，经过了长时间跨平台的测试，保证了机器人运行过程中的可靠性。最后， HandsFree 使用了 Kinect 或者 Xtion 等成本低，可靠性高的 RGBD 摄像机，使用最为成熟的 gmapping 来作为SLAM的关键技术，因此，HandsFree 能够保证性能出众的同时也能做到低价。总而言之，HandsFree 是一款非常好的ROS平台，不仅可以让新手快速入门学习ROS，又能够让学校企业可以低成本地专注研究集群等热门机器人领域。 个人觉得 HandsFree 团队的开源情怀和敬业态度值得敬佩。在国内其实类似的ROS机器人卖家很多，我也接触过其他具体的产品，不过真正让我感受到不一样的地方是 HandsFree 对待买家的态度，电机人为因素烧坏了立马更换、不管是不是买家，只要有人提问了，社区群里的团队成员们也是尽力解答。不论机器人还是开源库， HandsFree 的开源精神都能帮助到更多的西恩ROSer，让更多的人体会到西恩开源的力量。 甜甜的柚子 杭州电子科技大学博客园 : https://home.cnblogs.com/u/eat-too-much/ 现在的开源项目个人觉得以计算机互联网为盛，涉及嵌入式的项目个人觉得不多。EE想转CS的，不可谓不多。我也曾经想过，EE实在是太繁杂了，小到电烙铁，大到示波器，有的时候还经常出现莫名其妙的情况，百思不得其解。有些不了了之。有些恍然大悟。而计算机的人，太多的人写博客，太多的人愿意分享，讨论，一句“PHP是最好的语言”，有些群便可以炸了锅。。。 HandsFree 是我毕设的指路人吧。我是做底板的。上层的我没有很深入的接触。handsfree的这种分享精神真的值得我们对电子有兴趣的人认真学习，当你是“小白”的时候，好问，当你是“大牛”的时候，好答。作为每一方其实都有许些收货与精进。同时应该尊重开源知识，或者是遵守相应的开源协议。 一方风景 学校:电子科技大学中山学院实验室:中山市嵌入式系统公共实验室Github:https://github.com/TifferPelodeCSDN:http://blog.csdn.net/tifferpelode HANDSFREE开源项目是一个对ROS学习者来说很好的实验平台，具有高拓展性和鲁棒性。对于掌握了ROS基础知识，急需实物来进一步学习的人提供了一个理想的实践平台，项目全开源也使我们可以在其原有的基础上做适合自己想法的功能。 HandsFree 故事和酒   今天就是想和大家聊聊HandsFree。   HandsFree是一个开源的移动机器人开发平台，后来学长们把它做成了社区。   它怎么来的呢？   两年前，学校舞蹈机器人基地有个电子组学长，在基地电子组干了得有两年多，几乎把基地各个项目电子组的活儿都摸了个遍。有天他敲代码连续敲了有13个小时，突然发现自己的手累的都没办法抬起来了。   这学长懒啊，然后他就想，我特么一个电子组的整天在这儿这么苦逼的敲代码,不行啊,以后我要解放双手，去搞上层啊。以后一定要造一套轮子，不管要做啥机器人，都不用重新写一遍代码，不用重新调PID，自己就再也不用干这些底层的重复性民工活儿了,一定要实现HandsFree，那该多好。嗯，这还是一个伟大的梦想，一定会实现的。然后学长就坐那耷拉着手开始嘿嘿嘿笑起来了。。。。   没想到的是，他这么懒的一个人有了这样一个念头之后，真的就忘不了了。。。他想搞机器人啊，他真的觉得自己以后很有可能就天天搞机器人了，既然这样，他就一定要造一套好轮子，能够实现HandsFree，让自己专心做有前途的上层。于是，就在大三快放暑假的时候，在他刚刚感到有大把时间可以供自己自由分配的时候，他终于按捺不住了，开始没日没夜的写HandsFree，他就开始朝着自己那个能让自己嘿嘿嘿笑的梦想开始努力了。   其实这学长的学分积已经非常可怜了，80%，在基地厮混了这么久，哪里有时间想着照顾学分积呢。但他依然在那个时候，在准备考研的时候，疯狂的敲了一个暑假。开学之后，他本来准备忍痛放下HandsFree,复习考研。但没想到，那一年政策变化，80%的他居然也成功保研。。。听到这消息他立马就把考研书扔一边儿，屁颠儿屁颠儿又跑过去整HandsFree了。   第一版写完之后,学长非常开心的把HandsFree的嵌入式库分享给老学长,老学长看完之后说这玩意儿不错啊，我们还能用呢。他又很开心的分享给狗哥他们，狗哥他们也说好。后来就说，这么好的玩意儿咱别自己用了，咱整开源吧。起个好名字，就叫OpenRE（Open Robot Embedded）。然后狗哥刚好还和Exbot的管理员关系不错,易科就说你们这玩意儿也挺不错的,我们帮你们推广下吧。一推广就火了，大家建了个群，第二天就200人了。   后来啊，要不怎么说兄弟情深，要不怎么说情怀啊。基地他们那一届，A叔，狗哥，陈映冰学长，汪志康学长，邵琪杰学长都在呢，说你干吧，好不容易咱基地也整个开源项目，我们都帮你。从基地退役之后，没了经费，他们搞机器人也要生存啊，那就卖机器人吧，就卖HandsFree机器人。   以上这些,就是我对HandsFree历史的一些粗浅印象,可能有失实和夸张的部分。   问过学长之后,他给了我当时的一篇日记(2016.1.3)原文如下:   四个月前，我决定慢慢脱离底层，但是在这之前，我要把之前搞过的东西总结成一个库，方便以后再次使用时不需要再次研究底层的东西，并且这个库要具备强大的可移植性，可扩展性，完备精简，方便快捷，我大概花了一周的时间搭好一个基本框架，并使用ROS Package 和 Node的概念，以便于扩展各种功能包，并把所有MCU相关的代码有条理的封装成一个和MCU同名的文件夹，使用C++方式来封装每个功能包，同时把操作系统组件封装到一个文件夹，这样，即使一个不懂嵌入式的人，也可以很轻松的用这个库来开发。   然而做到这一步，并没有我一开始想的那么轻松，我花了1个半月的时间，改了好几版，才写好一个仅仅支持STM32F1的库，这一个半月，让我痛苦不堪，每天一醒来就在写，写到着整层楼的人都睡了，天天如此，我当时唯一的念头就是，一旦写好，我就可以HANDS FREE了，并且全部开源的念头也是在这种情景上诞生的，我希望别人不要在干这种浪费生命的活，我把这第一个版本命名HANDS-FREE-V1.0发布在基地里，希望有人和我一起搞。   可是现实并不美好，除了获得几个赞外，啥都没有，关键时刻还得靠基友啊，于是我去找陈映冰，把我的想法告诉他，正好那个时候，他在搞移动平台，并且正在着死画板子，敲着死代码，可以说是和我之前的情景一样，于是我们一拍即和，两个人精心配合一直到现在，在合作的两个月里，我们一起制定了HANDS-FREE-PCB的协议和统一的lib，一起完善制定开展了模块化PCB思想，一起精心设计ALL FOR ONE的主控的一代，二代，三代，他还设计了HANDS-FREE的电机驱动，并且一起完善了HANDS-FREE嵌入式框架在STM32 F4平台上的支持性，那段时间，我们基本天天通过语音来合作，也有好几次想要放弃，更要命的是，我们各自不满对方的想法，直接在QQ上开始撕逼大战，不过还好他脾气好，不然HANDS-FREE就夭折了，我和他也基本完成了硬件和嵌入式的框架，总而言之，没有他，我早就放弃了，他是我在HANDS-FREE项目中最给力的助攻。   也是在和陈映冰搞了一个月后，我想到我毕设需要3个移动平台，于是我找到汪志康帮我设计机械部分，我的毕设和廖新一一起做，做了HANDS-FREE这么久，移动平台自然是要在HANDS-FREE的基础上完成的，于是建立机械标准的想法自然就诞生了，于是HandsFree就变成了一个以嵌入式框架为核心，机械，硬件为分之的平台了，汪志康很给力，虽然他不太懂硬件和嵌入式，不过他却很支持HANDS-FREE的理念，他定义HANDS-FREE机械标准和设计了,HANDS-FREE-Robot-3WD V1.0,也是他让我想到这个硬件平台是可以为更多人服务的。   发布HANDS-FREE1.0后，我就把阵营搬到毕设教研室，也就是说后面的进程，我都是在教研室搞的，毕设是ROS,在这段时间里，我做了一个决策，让HANDS-FREE以ROS机器人开发的开源平台的形式推广出去，机器人越来越火，需要以机器人开发平台的人也越来越多，而国内基本没有一个好的开源平台，HANDS-FREE已经封装了机械，硬件，和嵌入式，而且廖新一在EXBOT上的影响力不小，所以我们具备了很多可以推广的条件，于是我开始规划HANDS-FREE的推广计划。   后面的发展和一开始规划的差不多，我们和EXBOT达成了合作关系，只不过让我没想到的是，EXBOT先来找我，而不是我去找他，我更坚定了这个平台的需求，我们约定，1个月也就是2月1号之前，在EXBOT官网上推出HANDS-FREE-Robot-3WD，他们负责ROS教程编写和宣传HANDS-FREE，接着我说服了我的毕设导师，和教研室达成了合作，于是我们有了资金和后续技术支持，教研室负责视觉SLAM和机器学习的软硬件开发，接着找到邵琪杰，于是HANDS-FREE-Robot-人形也就加入进来了，后来在基地发布了HANDS-FREE-Robot-1.5，吸引了一些学长以及他们的创业团队和基地小伙伴们，HANDS-FREE的维护成员于是开始增长，我相信，随着越来越多的人加入进来，HANDS-FREE的目标很快就会实现。   后来HandsFree团队内的人聚聚散散，车也是有空了造几台卖一把。16年上半年干的比较起劲，暑假还去了好多学校和公司讲了讲HandsFree。但是下半年研究生就开学了，大家都有课，都有一堆新的人在等着自己认识。发展速度就慢慢慢了下来。但是因为社区早已经建起来了，当时在我们这批还在基地服役的队员里面。。。HandsFree的名声还是神秘而装逼的。。。。   去年冬天的时候，学长跑到基地来拉皮条了。自己一个人带着个PPT。我就舔着脸认识了学长。我们一些人也就趁着比赛帮学长推广项目的名义加进了HandsFree。   大学，是每个人的青春。不甘寂寞的人总是会寻找各式各样的出路，来度过漫长四年。或者是学生会、社团，运动会，又或者是加基地，进实验室。我们把自己最黄金的两年多时间投入到里面，以至于很多年后回想大学生涯，这依然会是我们的谈资。有些人，很难能可贵的，就会在这个过程中找到自己想要的东西。   学长，就是这样的一个人。基地，就是这样的一个组织。我们在这里发现对机器人的热爱，很多人就从这里开始走上了一条以前从未想象过的道路。   至于我，现在正大三，过年前本来想的是这学期要放弃一切竞赛，准备安心学习复习的。本来参加比赛的时候想的就是帮学长打个宣传，宣传完也就没事了。。。但没想到真的越陷越深了。。。   一开始是在和学长有过一次快四个小时的长谈之后，真的是被他这种对机器人的热爱和开源精神打动了，我发现我们两个在很多理念上非常契合。开源精神，听起来像做公益，像做慈善。但是谁让我真的有这方面的愿望呢。一路走来，很多地方都曾受人恩惠，被人提携。我们每个人其实都是在社会成长，利用社会的资源，也要尽可能的回报社会。曾想着是等自己有大把大把的钱了，再回报社会。但随着自己在“马克思主义道路”（一本正经脸）上感触越来越深，思考的就慢慢的变了。何必非等到以后呢？所行就是所想，所做就是为人。真想回报社会，就不会找借口等到以后。你就从现在做起，从能摸得到的身边人做起，帮助他们，这就是回报社会。   更何况，HandsFree里面还寄托着一群人对机器人的梦想。想一想我们在搞的机器人，中国现在做智能机器人的核心青年力量，都是曾参加过中国机器人大赛，RoboCup的一批人。然而近几年随着一批顶尖高校的退水（转向国际赛放弃国内赛），和比赛本身生命周期的发展，真正甩着膀子在这个比赛上往前冲的人越来越少了。仔细想想，中国现在到底有多少机器人人才储备军啊？985高校的学生可能在本科生阶段会比较单纯的参与进去，但是到了大四或者研究生，被实验室的项目牵着走，转而追求一些其他的东西了。再加上有些实验室的保密氛围或者封闭性，除了发论文卖产品之外，能为这个社会机器人事业的发展贡献的力量就更少了。可是你看啊，中国未来对机器人的需求是多么巨大。现在行业对机器人人才的渴望是多么强烈。原先互联网时代那群人是多么希望跟上时代步伐也来开发机器人。现在的国内虽然有易科这样的机器人社区，但是对很多想入手机器人的人来说，还是缺少一个开放友好的机器人开发平台啊。   还有时代在发展,技术在迅速的进步。每一年顶会上发的论文趋势都在变化。你拼了命的学习，看代码，还不一定赶得上熟悉前沿技术，更别说投入那么长的时间调机器人了。   机械、电子、软件都在发展，仅就基地而言，软件组从三年前开始引入ROS,去年开始上深度学习FasterRcnn,三年前出去的人现在回来看都不一定跟的上了。有人说，你就一个本科生，比赛需求还那么低，搞那么多牛逼的东西干啥？基础的东西你都学完了吗？时代在发展啊，大兄弟。几百年前人们花几十年时间学习牛顿定律，但是当他发展成熟之后，今天我们一本初中课本就能让你学完最核心的知识。生产力发展的需求在推着时代往前走，不断的弃旧扬新。不断的压缩远离时代的知识的学习时间，把时间挤出来发展新技术，新应用，提高生产力。一代人有一代人的使命，上一代人搞好的东西，交到你手里，你就可以直接用，是让你来发展新东西的。07年别人拿PCA做个人脸识别，还是个挺新的玩意儿，今年你还拿他来做创新实践，得了吧，半天实验熟悉一遍就做完了。你要是时间充裕还行，别人已经造出来的东西，你就跑过去复现一遍，体会创造思想，但也仅此打住。不要再浪费时间了。时间是多么宝贵啊，你花时间学习旧的，是为了发展新的啊。这么多东西等着你学，你还守在过去的一个炕里面站不起来啊。   很多人说害怕未来人工智能机器人时代到来他们失业,但其实对我们这群搞机器人的人来说,这恰恰就是我们的事业啊,未来几十年内，这么好的机会就再等着我们呢。HandsFree把整个的嵌入式软硬件开发环境都移植到了Linux上，OpenRE还把一系列机器人开发过程中的嵌入式代码进行了封装，出于实际机器人开发经验的需要，丰富了很多接口（包括电源。通信，调试这些），而且实现了全开源。后来我们把它总结成叫：分布式架构设计、硬件资源预留以及软件开放性优化。她极大的方便了这群搞ROS的人根据任务需要进行底层DIY，以及一群以前玩儿电子的人进入ROS。她这么一套东西，是真的能省去大量的开发时间的，以前开发个机器人准备比赛可能需要六七个人从头花七八个月的时间，但是用HandsFree之后，可能三四个人三四个月就能整个差不多了。   也就是说，她这个东西是真的能推动一批人进入到机器人学习中来，推动开源机器人事业的发展，为社会带来贡献的。西工大好不容易能出来这么一个被社会评价很好的开源社区，为什么不扶一把呢，这也算是西工大学生的社会担当，西工大在机器人开源社区对社会的贡献。公为天下，即从今日始。报效祖国，就从手边干啊。这么说，可能有点太伟光正，但是为什么就不能伟光正一点，把我们的初衷表达出来呢？   想通了这一点之后，我就决定加入HandsFree了。我们啊，搞HandsFree，真的是出于我们在基地培养出来的对机器人事业的热爱，是看到中国机器人事业发展壮大的希望，是愿意从我们自身开始，推动中国机器人开源平台事业向前发展的愿景。是开源精神。是在互联网时代开放氛围下成长学习的我们，也愿意和别人，和走在同一条道路上的人，分享经验，共同成长的共享精神。这是HandsFree团队凝聚在一起的精神支柱。   说起来团队，HandsFree团队现在稳定的队员不到10人，都还是西工大上学的学生。团队内部机械、电子、ROS，视觉，运营干啥的人也有。鼎力支持我们的老师是航空学院的教授布树辉老师。他们实验室在搞的是视觉SLAM和无人机。和HandsFree有非常紧密的联系。HandsFree要干的事情也很多，技术开发，教程编写，开源产品设计，网站搭建，社区推广等等。。   为了技术开发,我们要赶紧把底层要完善发展的工作做完。然后赶紧开始视觉SLAM，机器学习的学习。   为了维持团队正常运行花费，我们还忙着运营卖小车赚经费，给团队添置一些材料设备。   为了让HandsFree能被更多的人知道,我们还要忙着参加重量级的比赛进行宣传,整理好网站和社区方便推广。   之前有人问我们有什么困难。想了半天想不出来。我们到现在一直都是很幸运的。布老师不遗余力，不求回报的帮助我们，师兄师姐也始终支持我们。每有一个人肯帮助我们，我们都感到万分幸运。团队现在能不定期的进行技术交流会，有自己的局域网千兆带宽服务器，能有钱买自己的VPN，能顺利的卖六七十台车，在开心的时候挤出一点钱去吃顿大餐。社区发展到500人多，使用者涉及全国30多家高校和科研院所跟公司。包括中科院，哈工大，厦大，电科里面好多好多人都在我们社区里面。我们等于是站在巨人的肩膀上，被大家一把一把扶着起来的。我们是真心的感谢那些帮助过我们的人，不管是给我们在技术上提供支持，还是在团队发展、宣传上给我们提建议，还是帮我们转发推送，真的真的感谢你们。真要说现在哪里困难，就是我们现在技术上的难题甘之如饴，但商业化问题十分头痛。缺少精通运营，推广的人来帮助我们。上次去珠海,感触最深的就是时代的发展.大西北太封闭了,不管是社会文化还是科技发展，到珠三角才是触摸时代的前沿,这里这么多机会等着你抓住,这么多资源等着人来用。机器人这么前沿的东西就在这里，你要不去攻占，明天就可能被别人占领。   现在几个人忙里忙外累死累活也能勉强维持前进，但是人无远虑，必有近忧。团队也是啊，团队现在有不少人都面临着就业上研或者考研的抉择，等我们走了之后，不想让HandsFree就这么没了,我们还是真心的希望能再找到一些人和我们一起走下去,能找到在各方面都有些特长，还能热爱机器人的人，来储备一批发展力量。   大学青春时光宝贵，能找到这样一个团队，大家一起喝酒吃肉，指点江山,这是多么荡气回肠的事啊！ Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 17:11:35 "},"docs/About/About-US.html":{"url":"docs/About/About-US.html","title":"About US","keywords":"","body":"HandsFree的今生前世 就像歌里唱的那样，HandsFree才不是一个没有故事的男同学，大家在学习和使用HandsFree的同时，肯定也对HandsFree的过去有所好奇吧。我们将在这里与大家分享HandsFree成长的故事。 想法的提出 2015年的秋天注定是个不平凡的季节。我的一位学长获得了保研资格，而他在舞蹈机器人基地的电子组摸爬滚打了两年之后，终于迎来了脱离底层（嵌入式层）的机会。机器人学是一个庞杂的学科，学习机器人需要形成一个较为完整的体系，于是学长准备在大四阶段和研究生阶段转移到ROS和SLAM上的研究。但是他又不舍得将自己多年来积累的嵌入式层的知识和经验就此抛弃，于是HandsFree的构想诞生了。顾名思义，HandsFree就是解放双手。而在机器人学中，解放双手最好的办法无疑就是解决机器人学中重复造轮子的问题。HandSFree的嵌入式部分OpenRE就是将市面上使用较为流行的几款芯片统一打包，进行机器人底层驱动的编写，并进行封装。让使用HandsFree的机器人研究者们真正地面向机器人进行开发，而不用关心底层的细节，大大缩短了开发时间节省了开发精力。 过程的实现 HandsFree的想法出现后，学长就开始干活了。一个半月的闭关换来了HandsFreeV1.0的发布。也就是在这个过程中，他提出了将HandsFree开源的想法，因为他深受写底层无聊的代码的折磨，决定让大家跟着他一起解放双手。 第一版发布后，学长将HandsFree投入了西工大舞蹈机器人基地，希望可以找到志同道合的小伙伴。但是最终他却只收获到了几个点赞，大家似乎并没有想一起维护HandsFree的念头。好在好基友陈映冰喜欢他的这个idea，并投身到了HandsFree的建设中。他们两基本完成了硬件和嵌入式的框架。 同时，最亲爱的队友，机械组汪志康和软件组廖新一的加入让HandsFree拥有了一套完整的体系。机械的标准，嵌入式的标准以及软件的标准就同时建立起来了。在这段时间内，初期的团队核心们做了一个决定，让HandsFree以ROS机器人开发的开源平台的形式推广出去，机器人越来越火，需要机器人开发平台的人也越来越多，而国内基本没有一个好的开源平台，这正是可以利用的机会。 之后，HANDS-FREE-Robot-1.5的发布，吸引了一些学长以及他们的创业团队和舞蹈机器人基地的小伙伴们，HandsFree的维护成员于是开始增长，现在我们已经组建了一个稳定的20人的核心维护团队。借助西工大布树辉教授和EXBOT开源机器人社区扶持，HandsFree得來了第一波的发展。 团队 西安酷科迪乐智能科技有限公司 HandsFree的核心团队聚集了一批有实力的机器人开发与研究者，他们目前主要来源于西北工业大学的舞蹈机器人基地。团队的成员，都具有两年以上的一线机器人开发经历。大家在一起本着开源的精神和发展机器人事业的共同理想，探索HandsFree的发展方向，维护HandsFree社区的良好运转。 ![HandsFree Team() 历史贡献者 舞蹈机器人基地 西北工业大学舞蹈机器人基地是西工大唯一一个完全自主开发实物机器人的创新基地。经过多年发展，现已形成篮球机器人、舞蹈机器人、家政机器人、救援机器人四个项目组。其中，舞蹈机器人处于国内统治地位，救援机器人、家政机器人作为所有参赛队伍中唯一的本科生队伍也连续几年取得非常优秀的比赛成绩，刚刚成立的篮球机器人项目组作为今年的新起之秀已取得备受瞩目的成绩。基地十余年来坚持以技术为基础，现分为软件、电子、机械三个技术组。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 16:24:31 "},"docs/Products/":{"url":"docs/Products/","title":"Products","keywords":"","body":"HandsFree Products 本篇用于介绍，所有的HandsFree 的机器人，包含jilong stone mini giraffe 巴克 大白 无人机 机械臂 Mini Mini作为一款小型机器人，拥有23cm的直径，33.3cm的高度（含云台），不超过2Kg的重量，却有高达3Kg以上的负载能力和1.2m/s的最大运动速度。Mini的机体采用四层黑色哑光玻纤板（黑色亮光亚克力板）和9根亮光铝合金柱，具有很高的结构强度冗余度，保证了结构的稳定与可靠。Mini采用了前万向后双驱动轮的底盘布局，配备两个775电机，具有和体型不相称的强大动力。Mini能支持多款激光雷达(Rplidar A1、Rplidar A2、Hokuyo URG-04L、Hokuyo UTM-30Lx等)、多款主流控制器（Tx1、树莓派等），也支持assustion、Kinect等深度摄像头、单目摄像头。Mini体型小、功能强大、性价比高，非常适合入门者开发研究和多机集群应用研究。 Stone Stone为一款两轮驱动的智能车平台，其直径36cm，高125.2cm（含云台），空重约3Kg，最大运动速度大于1.2m/s，负载能力大于6Kg。Stone主体结构由三层高强度哑黑玻纤板和16根亮光铝合金柱组成，保证其具备很高地稳定性和可靠性。Stone底盘采用前万向后双驱动轮的布局，并配备的12V驱动的775电机和8400mah高容量锂电池，使其具备强大动力和持久的续航时间。Stong能支持多款激光雷达(Rplidar A1、Rplidar A2、Hokuyo URG-04L、Hokuyo UTM-30Lx等)、多款主流控制器（Tk1、Tx1、树莓派等）、也能支持Dobot 1、Dobot m1等小型机械臂。另外，高置可变高度的云台能兼容多款RGBD摄像头和单、双目摄像头，并能提供270度的周向旋转角和180度的俯仰旋转角。 Giraffe Giraffe采用全封闭的结构布局，从而有效避免了精密电路可能被外力损伤的问题。和开放式布局的Stone以及Mini相比，Giraffe可能外表上透露出一股神秘，给人一种无法捉摸的感觉。但设计人员别具匠心地将Giraffe的左右侧板和后侧板设计成类似于门的开合式，从而使接线、检修变得和开放式布局的Stone一样简单。考虑到用户使用的便捷舒适，Giraffe左右侧板和后侧板边缘采用了磁吸，让开关侧门变得顺手随意。Giraffe底盘采用了前万向后双驱动轮的布局，保证了车体在前进和转向中的稳定。Giraffe底盘采用同步带传动，能精确地将电机输出位移传递给轮轴，并同时优化了底盘受力形式，大大提高Giraffe载重能力。Giraffe直径38cm，高126.2cm（含云台），空重约12Kg，最大运动速度达大于1.6m/s，最大承载能力达30Kg。Giraffe可同时配备一前一后两个激光雷达(Rplidar A1、Rplidar A2、Hokuyo URG-04L、Hokuyo UTM-30Lx等)，支持多款多款主流控制器（Tk1、Tx1、树莓派等）。Giraffe配备可调高度的两轴模拟舵机云台，能兼容多款RGBD摄像头和单、双目摄像头，并能提供270度的周向旋转角和180度的俯仰旋转角。 HF Arm机械臂 HF Arm1机械臂是HandsFree研发的第一款机械臂。其拥有5个自由度，能实现顺畅自如地旋转、伸缩、抓取等动作。HF Arm1总重7Kg，采用直流电机作为伺服动力。为了降低臂根弯矩，降低对伺服电机的扭矩需求，提高机械臂的稳定性与定位精度，HF Arm1采用了将伺服电机固定在臂根而用同步带将扭矩传至臂稍关节的布局。HF Arm1的抓取水平范围为（0.46m,0.9m），周向旋转角度大于180度。 巴克 巴克是18自由度智能人形机器人，使用优必选公司的数字舵机。整机共有9个钣金件、2个铣件、2个线切割铝件及7个3D打印件。为统一全机机械安装标准，各零部件间连接皆采用M2的螺钉及螺母。巴克配备有高清双目摄像头和语音识别系统，能准确地识别出不同颜色的不同物体及不同的语音命令。良好的机械结构设计让巴克能轻松完成俯卧撑、劈叉、航母Style等高难度的动作。正是基于这些引人注目的设计，巴克才能获得“2014中国机器人大赛暨Robcup公开赛”自创双足人形组一等奖。 大白 大白是20自由度的智能人形机器人，采用了森汉公司SH-15F型号的舵机。其腿部有10个自由度，手臂8个自由度，头部1个自由度，除此之外在机器人的腰部有另外加了一个自由度，能够实现普通人形机器人实现不了的转腰的动作，使机器人更具灵活性和观赏性。在机械结构设计中，大白采用了很多创新的机械结构对受力比较大的舵机进行了优化。比如在腰部旋转舵机的多盘外侧增加了推力滚针轴承，大大减小了腰部舵机所受的轴向力，从而解决了以往机器人腰部舵机因直接承力造成的磨损问题。设计中，经过多次计算和仿真，大白采用了L型腿部结构，有效缩短了腿部长度，减小腿部舵机力矩，也降低了全机的重心，提高了稳定性 。 除此之外，结合Kinect1.0，大白能准确地识别出人类地肢体动作，从而做出相同的动作，实现了人机动作交互。这在历年的中国机器人大赛舞蹈人形组比赛项目上属于首创。另外，多达20的全机自由度数和优秀的结构设计使大白，能顺利地完成俯卧撑、劈叉、飞跃、行走、航母Style等高难度动作且能实现摔倒后自主站立。这些出众的能力最终使大白获得“2014中国机器人大赛暨Robcup公开赛”自创双足人形组冠军。 Jilong 2WD 基隆2WD全机采用半封闭的机体布局，高400cm，直径36cm，空重2.5Kg. 基隆采用前万向后双主动轮的底盘布局，负载能力达6Kg，最大移动速度为0.8m/s. 基隆可搭载Raplidar A1、Hokuyo UGR-04L等多型激光雷达，支持Tk1、树莓派等主流控制器。另外，Jilomg 2WD搭载一两自由度的数字舵机云台。在云台上可以安装Xtion、Kinect等。 Jilong 3WD 基隆3WD机体结构和JIlong 2WD类似，也采用了半封闭的亚克力机身。基隆3WD采用三轮全向轮的底盘设计，高400cm（含云台），直径36cm，空重2.0Kg，负载能力达6Kg，最大移动速度为0.8m/s.基隆3WD可搭载Raplidar A1、Hokuyo UGR-04L等多型激光雷达，支持Tk1、树莓派等主流控制器。和2WD版本一样，基隆3WD也配备一可安装Xtion、Kinect的两自由度数字舵机云台。 HandsFree Mini 　　23cm直径机身，四层黑色哑光玻纤板，9根10mm直径高强铝柱，12v驱动775电机，mini带来的不仅是体型上的小巧玲珑和机械结构的高可靠度，还有出色的动力学性能和别具一格的机械美感。mini作为一款小型机，却能够同时支持激光雷达、tx1、深度摄像头等，是初学入门，多机集群研究的不二选择。 HandsFree Stone 　　前置万向轮的两轮驱动方式让车体拥有优越的稳定性；一对775电机加64mm铝合金轮保证了强大前行动力；三层高强玻纤板加8根铝柱组建的骨架在保证承力可靠性的同时以一种简洁明快的方式将各部件一无保留地呈现给使用者。从此，安装、接线、测试、检修，一目了然。毫无意外，Stone能够支持多种激光雷达，多种控制器（Tk1、Tx1、树莓派等），也可以支持小型机械臂，如dobot m1。另外，Stone高置的云台能够兼容多款RGBD摄像头和单、双目摄像头，并能提供270度的周向旋转角和180度的俯仰旋转角，让障碍一览无余。 HandsFree Giraffe 　　全身通体的黑色让Giraffe像黑衣武士一样暗暗地透露出一股邪酷。全封闭式的结构让其有一种不可言状的神秘。不过不要担心，Giraffe的左右侧板和后侧板采用了门式的开合结构。门侧采用了磁吸设计，让门的开合变得随意起来，从而让买家能更轻易地走进这个黑武士的内心，感受其缜密心思。同步带的传动方式使电机能精确地将转动位移传递给轮轴，也使Giraffe拥有多达30公斤的载重能力。Giraffe能够同时支持前后两个激光雷达，同时能兼容多种控制器（Tk1、Tx1、树莓派等）。健壮的身板使其能够搭载大、中型机械臂，从而使其更具实用能力。高高立起地云台是它不屈的头颅，也给它赢得了“Giraffe（长颈鹿）”这一名号。这个“头颅”上可以支持多款RGBD摄像头和单、双目摄像头，使其能轻易而精确扑捉到自己“指尖”的动作，完成主人交给它的各项指令。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 12:58:53 "},"docs/Products/Mini.html":{"url":"docs/Products/Mini.html","title":"Mini","keywords":"","body":"4.1 Mini 概述 Mini是一款采用前万向后双驱动轮底盘布局的小型机器人。其整机结构采用平板桁架式透明化设计，外形简约大方，能支持多种激光雷达，TK1、树莓派等主流控制器，可搭载assustion、Kinect1 、Kinect2等深度摄像头。Mini体型小、功能强大、性价比高，非常适合入门者开发研究和多机集群应用研究。 外形及性能参数 机器人参数 值 空重 直径(cm) 23 高度(cm) 20.4（不加云台） 33.3（加云台） 最大速度(m/s) 1.2 额定承载能力(kg) 3 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的控制器 TK1，RK3288，树莓派，pcduino 设计特点 23cm直径机身，四层黑色哑光玻纤板（亚克力板），9根10mm直径高强铝柱，12v驱动775电机，mini带来的不仅是体型上的小巧玲珑和机械结构的高可靠度，还有出色的动力学性能和别具一格的机械美感。透明化的结构设计使用户的安装、接线、调试、检修顺手简单。麻雀虽小，五脏俱全，Mini小小的体型上能同时支持多种传感器和主流控制器，能运行HandsFree团队开发的任何软件，是初学者入门及多机集群研究、应用的不二选择。 实验演示 Mini 小巧玲珑，售价底，适合学生入门 和 用于研究多机器人协同。然而Mini虽然小，却五脏俱全，在移动，建图，导航，避障方面的效果并不会比Stone 和 Giraffe 差，只是载重小，不能放机械臂，PC，这样就限制了机器人其他方面的研究，所以需要更高平台需求的可以看Stone和Giraffe 基于深度强化学习的多机器人去中心化避障实验 by Dorabot 去中心化的多机器人避障（decentralized multi-robot collision avoidance） 目标在与多机器人系统在没有中心服务器规划，甚至机器人间没有通讯的情况下，也能拥有高效， 无震荡（Oscillation-Free）机器人避障行为。可以类比在拥挤的街道上行走的人们。基于handsfree 我们构建了完善的实验平台，在我们的实验中，handsfree极大减少了底层开发的难度，加速了我们实物机器人实验进程。 安装说明 零件清单 1.玻纤板（亚克力板）五块：一层板、二层板、三层板、四层板、激光雷达转接板 2.万向轮一套，海绵轮两套（包括联轴器），775电机（含减速组和固定架）两套。50mm长铝柱10根，30mm长铝柱4根，20mm长铝柱三根。 3.螺钉、螺母若干（考虑到螺钉、螺母为细小部件，易丢失损耗，特意多配几个以作备用）。 组装步骤 电机装配 首先，将电机和L形电机支架用6个M3的螺钉连接起来即可，记得拧紧螺钉哦。 然后把海绵轮套在电机输出轴上，拧紧紧定螺钉就可以了。 将电机安装在二层板上 如下图，将固定架和二层板通过四对螺钉螺母固定在一起，记住螺钉头要向上。 左右电机都安装好后，是酱紫的： 主控的安装 主控是通过四个16mm长的铜柱安装到二层板上的： 万向轮的安装 如图，安装万向轮时只需将其和一层板通过四对M4的螺钉螺母连接即可。 激光雷达的安装 将激光雷达安装在激光雷达转接板（支持、、、、、雷达）上后，将激光雷达转接板和一层板通过四根10mm高的铜柱和8个M4的螺钉连接 第一、二层板的连接 一、二层板之间通过三个20mm长的铝柱连接。前面的两根铝柱可以通过双头螺柱和二层板上的铝柱连接。既然安装到这里了，就顺便把二层板上的四根80mm（50mm铝柱和30mm铝柱通过双头螺柱串联实现）铝柱竖起来吧。 第三层板的安装 第三层板的安装很简单，直接把二层板上的四根铝柱一端拧上双头螺柱，再使螺柱穿过三层板上的四个通孔和三层板上50mm铝柱连接就行了。（注意：要加TK1、树莓派、pcduino的小伙伴需要在安装三层板之前把控制器安装在三层板上） 第四层板的安装 将四颗M4的螺钉穿过顶板上对应的四个孔拧紧在铝柱上即可。 电池的安装 电池通过魔术贴贴在二层板的背面即可。 Xtion的安装 Xtion需要先通过一个螺钉安装在Xtion支架上。再使支架通过两个501mm铝柱固定在四层板对应的孔位上即可。（Kinect1.0的安装与之类似，只是孔位不同） 附录： 各结构板件安装孔位说明 一层板： 二层板： 三层板： 四层板： 激光雷达转接板: Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:19:20 "},"docs/Products/Stone.html":{"url":"docs/Products/Stone.html","title":"Stone","keywords":"","body":"4.2 Stone 概述 Stone是一款采用前万向后双驱动轮底盘布局的智能车平台。其整机结构采用平板桁架式透明化设计，外形简单又不失机械美感。Stone可搭载Dobot1、Dobot m1等小型机械臂，能支持多种激光雷达，TX1、TK1、树莓派等主流控制器。其配备高度可调的两轴云台，兼容多款RGBD摄像头和单、双目摄像头。 外形及性能参数 机器人参数 值 空重 约3kg 直径(cm) 36 高度(cm) 32.2（不加云台） 125.2（加云台） 最大速度(m/s) 1.2 额定承载能力(kg) 6 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的设备 Dobot机械臂 1/2，HF云台，双目摄像头，单目高清摄像头 支持的控制器 TX1，TK1，RK3288，树莓派，pcduino 设计特点 前置万向轮的两轮驱动方式让车体拥有优越的稳定性；一对775电机加64mm铝合金轮保证了强大前行动力；三层高强玻纤板加8根铝柱组建的骨架在保证承力可靠性的同时以一种简洁明快的方式将各部件一无保留地呈现给使用者。从此，安装、接线、测试、检修，轻车熟路，一目了然。毫无意外，Stone能够支持多种激光雷达，多种控制器（Tk1、Tx1、树莓派等），也可以支持小型机械臂，如Dobot1、Dobot m1。另外，Stone高置的云台能够兼容多款RGBD摄像头和单、双目摄像头，并能提供270度的周向旋转角和180度的俯仰旋转角，让世界一览无余。 实验演示 基于激光雷达的建图导航避障 (此处采用了Stone的前身Jilong的视频) 基于RGBD的目标跟踪(此处采用了Stone的前身Jilong的视频) 基于RGBD的建图导航避障 综合来说，Stone已经很好的个人机了，有一定的载重能力，支持Dobot机械臂，适合小实验室和个人机器人研究。但是还不能完成一些复杂的任务，比如抓取一瓶水，开个门，负载也有限，所以有更高需求的请看Giraffe，Giraffe有着庞大的身躯和超大的负载能力，可以支持UR5和KUKA的一些工业机械臂，或者配合HandsFree自主设计的低成本ARM，可以胜任大部分的机器人研究任务。 安装说明 零件清单 玻纤板五块：底板、中层板、顶板、云台支撑板、激光雷达转接板 万向轮一套，海绵轮两套（包括联轴器），775电机（含减速组和固定架）两套 铝柱16根，铝杆2根（选购）、云台一套（选购） 螺钉、螺母若干（考虑到螺钉、螺母为细小部件，易丢失损耗，特意多配几个以作备用） 安装步骤 电机安装 将电机和L形电机固定架用6个螺钉连接起来，并拧紧螺钉即可 主动轮的安装 将铝合金主动轮的轮轴套在电机减速箱动力输出轴上，并拧紧轮轴侧面的紧定螺钉即可。 电机在底板上的安装 将L形电机固定架和玻纤底板通过4对螺钉螺母连接在一起（具体孔位参见附图） 万向轮的安装 将万向轮和玻纤底板通过四对螺钉、螺母连接在一起。 激光雷达的安装 根据用户手头的激光雷达型号，先将激光雷达安装在激光雷达转接板上（孔位说明见附图）。然后将激光雷达转接板通过4根4*10mm的双通铜柱和8个螺钉连接在玻纤底板上。 电机驱动板的安装 将电机驱动板和玻纤底板通过4根20mm长的铜柱和8颗M4的螺钉连接起来。 主控板的安装 将主控板和玻纤底板通过4根20mm长的铜柱和8颗M4的螺钉连接起来。 支撑铝柱的安装 将两段铝柱通过双头螺柱串联成120mm长的铝柱，再将铝柱和玻纤底板通过M4的螺钉连接。 中层板的安装 使中层板上铝柱通过穿过中层板对应孔位的双头螺柱和底板上铝柱连接，拧紧铝柱，即可将中层板固定在两段铝柱之间。 顶板的安装 使M4的螺钉穿过顶板上对应孔位和中板上铝柱连接，拧紧螺钉，即可将顶板固定在螺钉和铝柱之间。 法兰的安装 Stone上多处使用了法兰，此处以顶板上法兰为例介绍安装方法。将法兰和玻纤顶板通过3对螺钉、螺母连接即可。（车体上所有法兰如下） 铝杆的安装 将直径19mm的铝杆自上而下依次插入顶层、中层、底层的法兰中，然后拧紧法兰侧边的紧定螺钉即可。 云台板的安装 先按照第11步的方法将法兰安装在云台板上，再将云台板通过法兰安装在两根铝杆上（使法兰的紧定螺钉穿过铝杆上的螺纹孔）即可。 Xtion的安装 先将Xtion的耳片插入3D打印的支撑件内，并扣合盖板，然后将3D打印的扣合件通过两对螺钉、螺母固定在云台的U形架上。然后再将支撑件和扣合件扣合在一起即可。 云台的安装 将云台底板通过4根40mm铜柱和8颗螺钉连接在一起即可。 电源管理的安装 将电源管理模块下面的四个橡胶脚垫放在玻纤底板对应的孔上，并轻轻用力压紧即可。 附录： 各结构板件安装孔位说明 底板: 中板: 顶板: 云台支撑板: 激光雷达转接板: Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:19:20 "},"docs/Products/Giraffe.html":{"url":"docs/Products/Giraffe.html","title":"Giraffe","keywords":"","body":"4.3 Giraffe 概述 Giraffe是一款采用前万向后双驱动轮底盘布局的智能车平台。其整机结构采用平板桁架式封闭式设计；侧板采用带磁吸可开合设计；传动系统采用同步带传动。Giraffe可同时支持一前一后两个激光雷达，兼容TX1、TK1、树莓派等主流控制器，配备高度可调、能兼容多款RGBD摄像头和单、双目摄像头的两轴云台。Giraffe可搭载HF Arm1等中型机械臂（总量15Kg左右），具有高达30Kg的承载能力。 外形及性能参数 机器人参数 值 空重 直径(cm) 38 高度(cm) 33.2（不加云台） 126.2（加云台） 最大速度(m/s) 1.6 额定承载能力(kg) 30 kg 支持的传感器 Rplidar A1/A2，Hokuyo URG-04L/UTM-30Lx，assusxtion，Kinect1/2) 支持的设备 HandFree arm，Dobot机械臂 1/2，HF云台，双目摄像头，单目高清摄像头 支持的控制器 笔记本，TX1，TK1，RK3288，树莓派，pcduino 实验演示 Giraffe在建图导航避障方面的效果和Stone Mini一样，这里就主要展示一下大型机械臂的3D运动规划和抓取，Giraffe是目前HandsFree功能最全，性能最强的平台，也是HandsFree Team目前研究机器人领域的主要实验平台。 设计特点 全身通体的黑色让Giraffe像黑衣武士一样暗暗地透露出一股邪酷。全封闭式的结构让其有一种不可言状的神秘。不过不要担心，Giraffe的左右侧板和后侧板皆采用了门式的开合结构。门侧采用了磁吸设计，让门的开合变得随意起来，从而让用户能轻易地走进这个黑武士的“内心”，感受其精细的内在。传动系统中同步带的传动方式使电机能精确地将转动位移传递给轮轴，也优化了底盘承力形式，使Giraffe拥有多达30公斤的载重能力。Giraffe能够同时支持前后两个激光雷达，同时能兼容多种控制器（Tk1、Tx1、树莓派等）。健壮的身板使其能够搭载大、中型机械臂，从而使其更具实用能力。高高立起地云台是它不屈的头颅，也给它赢得了“Giraffe（长颈鹿）”这一名号。这个“头颅”上可以支持多款RGBD摄像头和单、双目摄像头，使其能轻易而精确扑捉到自己“指尖”的动作，完成主人交给它的各项指令。 安装步骤 零件清单 玻纤板十块：底板、中层板、顶板、云台支撑板、激光雷达转接板（2个）、侧缘板（4个）；亚克力板四块：前侧板、左侧门、右侧门、后侧门。 万向轮一套，铝合金轮两套，电机（含减速组和固定架）两套，轮轴两根，轴承座4个，同步带轮4个，同步带两条。 铝柱32根，铝杆2根（选购）、云台一套（选购） 螺钉、螺母若干（考虑到螺钉、螺母为细小部件，易丢失损耗，特意多配几个以作备用）。 装配步骤 轮轴、同步带轮与轴承座的安装: 将轴穿过两个轴承座上的轴孔与同步带轮形成轴孔配合，并拧紧同步带轮上的紧定螺钉（先不要拧紧轴承座上的紧定螺钉）。 轮轴和主动轮的安装 将轮轴大头一端插入了轮的中心孔中，再拧紧轮外侧的拉紧螺钉即可。 主动轮在玻纤底板上的安装 将轴承座和玻纤底板通过四对螺钉螺母连接起来，然后拧紧轴承座上的紧定螺钉即可。 电机、电机固定架和同步带轮的安装 先将电机和电机固定架通过4个螺钉连接，再将同步带轮安装在电机轴上，并拧紧紧定螺钉。 电机的安装 将电机通过四对螺钉、螺母安装在玻纤底盘的槽孔上，注意稍将螺钉拧紧即可。 同步带的安装 将同步带套在电机和轮轴的同步带上，你可能需要前后调节电机位置，才能将同步带顺利安装好，然后需要调节电机位置使同步带张紧。 万向轮的安装 将万向轮和玻纤底板通过四对螺钉、螺母连接，拧紧螺钉即可。 电机驱动板的安装 将电机驱动板通过4根20mm长的铜柱和8颗螺钉连接在玻纤底板上。 主控板的安装 将主控板通过4根20mm长的铜柱和8颗螺钉连接在玻纤底板上。 前激光雷达的安装 首先将现有的激光雷达安装在激光雷达转接板上，再将激光雷达转接板通过4根10mm长的铜柱和8颗螺钉安装在玻纤底板上。 底板铝柱的安装 现将两段60mm长的铝柱通过双头螺柱串联为120mm长的铝柱，再将8根铝柱通过螺钉固定在玻纤底板上。 中层板的安装 使中层板上铝柱通过穿过中层板对应孔位的双头螺柱和底板上铝柱连接，拧紧铝柱，即可将中层板固定在两段铝柱之间。 后视激光雷达的安装 首先将现有的激光雷达安装在激光雷达转接板上，再将激光雷达转接板通过4根10mm长的铜柱和8颗螺钉安装在玻纤中层板上。 左右侧门及后侧门上合页的安装 以左侧门为例，将合页的一片通过两对螺钉、螺母固定在侧缘板上，再将另一片通过两对螺钉、螺母固定在左侧门对应孔位上。（全机共有6个合页）。 磁吸铁片的安装 以左侧门为例，将磁吸铁片通过两对螺钉、螺母固定在侧板的槽孔上（全机共有6个磁吸铁片）。 磁吸的安装 以顶板为例，将磁吸通过两对螺钉、螺母固定在顶板对应的孔上（全机共有6个磁吸）。 顶板把手的安装 将把手通过两个螺钉固定在玻纤底板后侧的孔上。 法兰的安装 以顶板为例，将法兰通过三对螺钉、螺母固定在底板上（全机有6个法兰）。 侧板的安装 将各前侧板及侧缘板卡到底板对应的矩形槽孔中即可。 顶板的安装 将顶板上的矩形槽孔卡入前侧板及侧缘板上的凸台。然后，使M4的螺钉穿过顶板上对应孔位和中板上铝柱连接，拧紧螺钉，即可将顶板固定在螺钉和铝柱之间。 铝杆的安装 将直径19mm的铝杆自上而下依次插入顶层、中层、底层的法兰中，然后拧紧法兰侧边的紧定螺钉即可。 云台板的安装 先将法兰安装在云台板上，再将云台板通过法兰安装在两根铝杆上（使法兰的紧定螺钉穿过铝杆上的螺纹孔）即可。 Xtion的安装 先将Xtion的耳片插入3D打印的支撑件内，并扣合盖板，然后将3D打印的扣合件通过两对螺钉、螺母固定在云台的U形架上。然后再将支撑件和扣合件扣合在一起即可。 云台的安装 将云台底板通过4根40mm铜柱和8颗螺钉连接在一起即可。 磁吸的调整 若感觉磁吸的效果不好（吸力过大或过小），可调节磁吸铁片的位置。 电源管理的安装 先将后侧门打开，再将电源管理模块下面的四个橡胶脚垫放在玻纤底板对应的孔上，并轻轻用力压紧即可。 附录： 各结构板件安装孔位说明 底板: 中板: 顶板: 侧门: 侧缘板: 后侧板: 云台板: 激光雷达转接板: Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:19:20 "},"docs/Products/Comparison.html":{"url":"docs/Products/Comparison.html","title":"Comparison","keywords":"","body":"HandsFree与Turtlebot对比 参数汇总 类型 Mini Stone Giraffe Turtlebot2 Burger Waffle 高度(cm) 20.4/33.3 33.2/125.2 33.2/126.2 12.48 19.2 14.1 重量(kg) 约3 5 1 1.8 直径(cm) 23 36 38 35.15 14,18 28,30.6 最大速度(m/s) 1.2 1.2 1.6 0.7 0.22 0.26 额定承载能力(kg) 6 15 40 5 15 30 主控板类型 STM32F1基础上开发的HandsFree mini ControlUnit STM32F4基础上开发的HandsFree Control Unit V2 STM32F4基础上开发的HandsFree Control Unit V2 未知 STM32F7基础上的Arduino开发板 STM32F7基础上的Arduino开发板 电源接口 12V5V19V(max均 3A) 12V5V19V(max均 3A) 12V5V19V(max均 3A) 19V/2A 12V/5A 12V/1.5A 5V/1A 3.3V/0.8A 5V/4A 12V/1A 3.3V/0.8A 5V/4A 12V/1A 支持外接设备 TX1,TK1,MiniPC,树莓派,Kinect ,HOKUYOU 雷达等 TX1,TK1,MiniPC,树莓派,Kinect ,HOKUYOU 雷达等 TX1,TK1,MiniPC,树莓派,Kinect ,HOKUYOU 雷达等 请参考上述接口 请参考上述接口 请参考上述接口 电源容量(mAh) 7800 7800 7800 2200/4400 1800 1800 ROS雷达导航开发 支持 支持 支持 支持 支持 支持 ROS视觉导航开发 支持 支持 支持 支持 未知 未知 下位机软件 OpenRE OpenRE OpenRE 未知 OpenCR OpenCR 价格(RMB) 1899/4499/6699 3399/5799/8699 9999 11399 5500 15500 说明: Turtlebot2除价格外其他参数均为Kobuki移动底盘的参数. 高度一栏格式为:不加云台高度/加云台之后高度 价格一栏格式为:基础版/导航版/视觉开发版 Turtlebot3系列直径为:长,宽 本文档为HandsFree机器人与Turtlebot公司机器人的对比报告,.报告内容将从硬件,软件,售后三个方面来进行对比. 一,概述 1.1 HandsFree HandsFree 是一个面向机器人研究、开发的开源软硬件系统。她有完备与科学的框架,以优秀的嵌入式系统框架为核心,精良的电路、机械设计为支撑,帮您快速实现多种形态的机器人。本系统包含机器人导航,SLAM,计算机视觉等模块,并拥有自己上层软件和调试系统。她支持国外其他的开源项目,如 ROS, MPRT, PIXHAWK 等,这一切都为您带来了无比的便捷和快乐! HandsFree现在主推三款机器人分别是Mini,Stone,Giraffe,分别面向不同需求.简介如下:1,Mini是一款采用前万向后双驱动轮底盘布局的小型机器人。其整机结构采用平板桁架式透明化设计，外形简约大方，能支持多种激光雷达，TK1、树莓派等主流控制器，可搭载assustion、Kinect1 、Kinect2等深度摄像头。Mini体型小、功能强大、性价比高，非常适合入门者开发研究和多机集群应用研究。效果如图: 2,Stone是一款采用前万向后双驱动轮底盘布局的智能车平台。其整机结构采用平板桁架式透明化设计，外形简单又不失机械美感。Stone可搭载Dobot1、Dobot m1等小型机械臂，能支持多种激光雷达，TX1、TK1、树莓派等主流控制器。其配备高度可调的两轴云台，兼容多款RGBD摄像头和单、双目摄像头。效果如图: 3,Giraffe是一款采用前万向后双驱动轮底盘布局的智能车平台。其整机结构采用平板桁架式封闭式设计；侧板采用带磁吸可开合设计；传动系统采用同步带传动。Giraffe可同时支持一前一后两个激光雷达，兼容TX1、TK1、树莓派等主流控制器，配备高度可调、能兼容多款RGBD摄像头和单、双目摄像头的两轴云台。Giraffe可搭载HF Arm1等中型机械臂（总量15Kg左右），具有高达40Kg的承载能力。效果如图: 1.2 Turtlebot 英文是介绍的原文,中文下面中文进行了简要的翻译 TurtleBot is a low-cost, personal robot kit with open-source software. TurtleBot was created at Willow Garage by Melonee Wise and Tully Foote in November 2010. With TurtleBot, you’ll be able to build a robot that can drive around your house, see in 3D, and have enough horsepower to create exciting applications.The TurtleBot kit consists of a mobile base, 2D/3D distance sensor, laptop computer or SBC(Single Board Computer), and the TurtleBot mounting hardware kit. In addition to the TurtleBot kit, users can download the TurtleBot SDK from the ROS wiki. TurtleBot is designed to be easy to buy, build, and assemble, using off the shelf consumer products and parts that easily can be created from standard materials. As an entry level mobile robotics platform, TurtleBot has many of the same capabilities of the company’s larger robotics platforms, like PR2.Turtlebot是一种低成本，具有开源开源软件的个人机器人开发套件。利用Turtlebot，你将能够建立一个可以驱动你的房子周围的机器人，看3D视图，并有足够的马力，并创造令人兴奋的应用。Turtlebot开发套件由一个移动底盘，二维/三维距离传感器、笔记本电脑或SBC（单板计算机），和turtlebot安装硬件套件组成。还有,对turtlebot套件来说，用户可以从ROS的wiki上下载Turtlebot SDK。Turtlebot设计易于购买，建造，安装，使用现成的消费产品和零件，很容易可以从标准的材料制造。作为一款入门级的移动机器人平台，Turtlebot有许多的公司更大的机器人平台相同的功能，比如PR2机器人。 下面简要介绍一下机器人,Turtlebot现存的机器人有第二代和第三代的机器人,这两代机器人差别比较大.1,Turtlebot2是一个系列,大部分都是由Kobuki移动底盘,华硕的Xtion深度摄像头/kinect深度摄像头,一个可以上网的笔记本,还有放置笔记本和kinect的各种结构,机器人.机器人主要的部分就是kobuki移动底盘,摄像头和可联网的PC.但是第二代机器人的移动底盘是封装好了的,内部机械及软件均是不开源的,只留下了更新固件接口及其他一些接口.因为不开源我们无法对其进行更多的分析,但不可否认的是,这个移动底盘确实比较稳定和准确.效果如图: 2,Turtlebot3也是一个系列,现在主要的两款是Burger和Waffle.主要由树莓派,一块Arduino板,还有雷达组成.有人尝试在上面加装深度摄像头和机械臂,但是感觉也只是装饰,由于高度的限制,只有雷达能够发挥出全部的作用.第三代机器人和第二代机器人来比较的话,变化非常大.(1)更加地低成本,选取的硬件都很low,有点面向高中生的意思,在上面计算怕是不行.(2),全部开源,第三代机器人的硬件软件全部是开源的,不像第二代,移动底盘是一个集成好了的产品.效果如图: 二,硬件对比 因为Turtlebot2并不是全部开源,所以我们在对比的时候会将所知的Turtlebot2的信息提及,但是主要将对Turtlebot3和HandsFree举例进行比较. 2.1 机械 2.1.1 参数差异 机械方面,HandsFree有三款机器人,小型的Mini到大机器人Giraffe,不同规格满足不同需求.Turtlebot方面第二代产品与我们的中型产品Stone大小类似,第三代产品与Mini类似.由于Turtlebot2的核心是kobuki移动底盘,我们将主要介绍kobuki的参数,下面是对比: 类型 Mini Stone Giraffe Kobuki Burger Waffle 高度(cm) 20.4/33.3 33.2/125.2 33.2/126.2 12.48 19.2 14.1 重量(kg) 约3 5 1 1.8 直径(cm) 23 36 38 35.15 14,18 28,30.6 最大速度(m/s) 1.2 1.2 1.6 0.7 0.22 0.26 额定承载能力(kg) 6 15 40 5 15 30 说明,高度一栏中HandsFree机器人的两个高度分别为加云台和不加云台,Turtlebot3系列直径为长乘宽. 2.1.2 说明分析 机械结构来说,HandsFree占据更多优势. 高度,要知道,所有的深度摄像头都有一个盲区,比如说Xtion2的有效距离是0.8~3.5m,但是Turtlebot3高度太低,会有很大的盲区.HandsFree每款机器人都有架高了的云台,视野更好. 速度,由于较好的稳定性,HandsFree的速度都要比Turtlebot要快 承载能力方面,相差不是特别大,而且如果是加装机械臂的话,感觉Turtlebot3底盘实在是太低了.Handsfree其中两款都可以加装机械臂,位置也比较合适. 云台,Turtlebot所有系列都没有云台,而HandsFree所有的机器人都可以加装云台,可以使视野更广. 2.2 主控制器 2.2.1 参数介绍 HandsFree中Mini用的控制器是HandsFree mini ControlUnit,另外两款使用的是HandsFree Control Unit V2,这两款软硬件全部开源.Turtlebot2底盘控制是个黑箱子,既不能自己拓展应用又不能自主开发,很赚钱,毕竟人家是专业的靠这个吃饭的,做出来的控制效果和里程计的精确度可能会比较高,但是没有参数,我们并不能进行比较,但是Turtlebot3是全部开源的,我们可以拿来比较一下(其实我都不想比,简直可笑...).HandsFree Control Unit V2,主要特征: 168MHZ STM32F407 Cortex M4 板载三轴陀螺仪，三轴加速计，气压计，三轴磁力计。 10PWM输入输出。 USBTTL, USB，microSD卡。 支持机型： 两轮平衡车，两轮差移动平台，三轮全向平台，四轮差速平台，四轮麦克纳姆轮全向平台，数字舵机人形，固定翼，四六八轴旋翼飞行器等。 细节看下图,可以在链接中查看更多细节. Turtlebot3使用的是基于STM32F7开发的Arduino开发板,MCU不错,板子上其他的东西不多: 我顺便把Mini的参数放上去吧: 2.2.2 说明分析 Turtlebot2的底盘控制器可能比我们的要好,已知的只有防撞传感器,红外传感器,防跌落传感器,110度/s单轴陀螺仪. HANDSFREE控制器，板载资源十分丰富，下料十足，可满足常见形态机器人研究需求，同时不惜成本，尽量选择稳定可靠的接口和IC，光是一个ADC基准电压的芯片就十几块钱，MOLEX接口也是选用昂贵的自锁接口，这主要是因为HANDSFREE团队本身也是使用这款控制器进行研究开发的，所以在很多细节方面考虑也是为了满足自己需求。同时HANDSFREE团队为该控制器开发了OpenRE嵌入式机器人库，用户可以方便的在此库的基础上进行应用程序构建。而且OpenRE是还可以完全支持在linux环境下开发，这大大方便了ROS开发者和不懂嵌入式的机器人开发者。 Turtlebot3的MCU比较高端,但是开发板上的资源倒是有限,感觉有点浪费了. 总结:Turtlebot3板载资源只能跟Mini稍微比较一下,和HandsFree第二代上的板载资源完全没有比较性.Kobuki底盘控制器参数未知,程序也不是开源的,无法进行比较,只能说可能有一定优势. 2.3 电源供电方案 2.3.1 参数介绍 Hands Free Power Manager V2.0 是 Hands Free Team 根据 Hands Free 开源项目的硬件标准设计的一款电源分配板，附带多路开关和多种电源转换功能，满足机器人多样的电力需求。 支持常用的 TX1， TK1， MiniPC，树莓派， Kinect ，HOKUYOU 雷达等设备供电，同时还支持机器人的电机驱动， 云台舵机，机械臂等结构的供电，还自带一个急停开关接口和一路急停电源输出。 配合大容量电池可以为机器提供集成供电方案。 Turtlebot2移动底盘有对外的接口,内置电池,Turtlebot3也设置了对外接口.下面是二者的对比: 类型 Mini Stone Giraffe Turtlebot2 Burger Waffle 电源接口 12V5V19V(max均 3A) 12V5V19V(max均 3A) 12V5V19V(max均 3A) 19V/2A 12V/5A 12V/1.5A 5V/1A 3.3V/0.8A 5V/4A 12V/1A 3.3V/0.8A 5V/4A 12V/1A 支持外接设备 TX1,TK1,MiniPC,树莓派,Kinect ,HOKUYOU 雷达等 TX1,TK1,MiniPC,树莓派,Kinect ,HOKUYOU 雷达等 TX1,TK1,MiniPC,树莓派,Kinect ,HOKUYOU 雷达等 请参考上述接口 请参考上述接口 请参考上述接口 电源容量(mAh) 7800 7800 7800 2200/4400 1800 1800 2.3.2 说明分析 无论是在电池容量和接口方面,HandsFree都相对更加优秀.HandsFree提供了专门的电源模块,支持的可搭载模块更多. 2.4 电机,驱动 HandsFree Motor Drive V2 是HandsFree Team根据Hands Free开源项目的标准开发的一款电机驱动器，是HandsFree开发的机器人Stone的硬件的组成部分之一。每块驱动板使用两块BTS7970芯片，可以驱动一个电机，保证足够大的驱动能力。同时能够将电源转接给其他驱动，极大的减少驱动电源线连接的复杂程度。 Turtlebot2驱动电机均未知.Turtlebot3使用Dynamixel X series;Burger电机为DYNAMIXEL (XL430-W250-T),Waffle电机为DYNAMIXEL (XM430-W210-T). 感觉这方面半斤八两吧. 三,软件对比 软件方面将从上位机软件(ROS)和下位机软件(OpenRE/OpenCR)分别介绍. 3.1 ROS ROS(Robot Operating System)是一个开源的平台,也是一个提供各种库文件帮助软件开发人员创建机器人应用程序的工具。它提供了硬件抽象层、设备驱动程序、库、可视化工具、消息传递、包管理，还有更多其他的。Turtlebot和HandsFree上层都是基于ROS进行开发,由于ROS的开源的性质,在上位机软件方面两类机器人差别不大,都可以使用ROS库进行开发,Turtlebot的Demo和HandsFree的Demo都是大同小异,互通有无的.所以,在这方面,二者没区别. 3.2 下位机软件 Turtlebot2不是开源的,所以没有第二代的资料,也就是说第二代底层是不支持二次开发的.Turtlebot3下位机软件为OpenCR,开发工具为Arduino的IDE. 具体代码没有研读,不过考虑到主控板上资源较少,就算进行二次开发也很受限制.HandsFree下位机软件为OpenRE. OpenRE全称Open Source Robot Embedded Library，是一个专门为机器人写的、基于STM32系列微处理器的嵌入式开源库。经过不断优化，开源库变得鲁棒和通用，从而独立于平台成为一个专门为机器人而生的一个嵌入式库。主要目的是搭建一个专门为机器人服务的嵌入式跨平台软件框架，涵盖底层设备驱动，算法库，通信与操作系统组件等，主要涵盖以下内容： 封装了许多传感器、存储器、输入输出设备的驱动包，并且采用硬件和驱动包隔离的方式，开发者可以轻易的跨平台移植，比如各种伺服设备、数模舵机、直流三相电机、各种传感器、加速计，陀螺仪、磁力计、超声、 GPS、一些交类互 LCD、触摸屏、 flash、 EEPROM、 SD 卡驱动等。 具有已经移植好的操作系统层功能，实时操作系统（ RTOS），图形库（GUI），网络协议（LWIP）， USB 协议，使用者可以根据自己的需求，选择合适的模板进行开发，省去了移植过程的繁琐操作。 具有很多机器人有关的算法库、 PID 控制包、机器人运动坐标变换包、卡尔曼滤波包、矩阵运算包、四元数等。 支持Linux环境下的makefile + QTCreator + armgcc来进行开发 总结:Turtlebot2下位机软件可能会存在算法上的优势,但是不能进行二次开发,第三代开发受限制很多,总体来说不如HandsFree的开源的下位机软件. 四,销售及服务对比 4.1 价格 价格方面也是碾压趋势,HandsFree三款机器人分别对应不同群体,价格区间在2000-10000不止,套餐选择很人性化.Turtlebot系列,第三代价格在6500左右,第二代只要移动底盘就4500,更不要说上面要架设kinect和联网笔记本了. 类型 Mini Stone Giraffe Turtlebot2 Burger Waffle 价格(RMB) 1899/4499/6699 3399/5799/8699 9999 11399 5500 15500 说明: 价格一栏格式为:基础版/导航版/视觉开发版 4.2 Wiki 因为两家机器人都是基于ROS,国内也有在推广ROS的各种组织,所以关于ROS方面的资料都可以找到.TurtleBot系列和HandsFree系列都提供较为完整的学习指导和培训，在GitHub上提供开源的代码供客户学习使用，有自己的讨论社区为广大机器人爱好者提供讨论分享，碰撞思维的平台。 Turtlebot系列的其他资料都以Wiki的形式给出,大部分资料都可以在官网找到. HandsFree的资料也是依靠gitbook整理形成的Wiki,所有资料都可以在里面找到.不仅如此我们还建有HandsFree社区,社区交流群: 521037187 (Hands Free Community) ,群内大部分都是HandsFree使用者及开发者,大家可以互相学习解惑. 4.3 Others HandsFree相对Turtlebot有天然的优势,一堵无形的墙.我们产品如果有什么问题,社区提问,或者直接找到我们公司都不是事. 有二十多所大学的实验室,使用了HandsFree平台作为研发平台 十几个创业公司使用了HandsFree作为原型机 软件框架更是被众多机器人爱好者所使用,社区论坛每天都有上千次的浏览量 HandsFree　搭建了自己的网站,交流社区,淘宝店,Github等,希望能帮助更多机器人开发者. 五,综述 硬件方面,由于Turtlebot2的不开放我们无法进行比较,但是通过与Turtlebot3的对比,我们发现资本主义都是纸老虎.不能说全面碾压Turtlebot3,但是可以说占据很大的优势了. 软件方面,同是支持ROS开发的机器人,ROS的驱动算法一类的又都是开源的,这方面差别不大,但是Handsfree仍然占据了高地,HandsFree的OpenRE代码解析详细,支持的编译工具更多,支持Linux环境下的makefile + QTCreator + armgcc来进行开发,更地满足了程序员的需求. 销售方面,我们搭配的套餐更加人性化,质量高,价钱低.服务与Turtlebot不相上下,我们还提供了大家互相交流的社区,以及及时方便的售后. 综上所述,HandsFree是进行机器人开发学习相对更好的选择. Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-15 15:19:51 "},"docs/Hardware/":{"url":"docs/Hardware/","title":"Hardware","keywords":"","body":"HandsFree Hardware Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 17:00:47 "},"docs/Hardware/Devices-Sensors.html":{"url":"docs/Hardware/Devices-Sensors.html","title":"Devices-Sensors","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-15 14:58:43 "},"docs/Hardware/Control-Unit.html":{"url":"docs/Hardware/Control-Unit.html","title":"Control Unit","keywords":"","body":"HandsFree ControlUnit（V2 & Mini） HandsFree Control Unit V2使用手册 目录 简介 原理图 板载资源 使用说明 简介 Hands Free Control Unit V2 是Hands Free Team在第一代主控的基础上改进而来，根据Hands Free开源项目的硬件标准开发的一款的运动控制器，由核心板和底板组和而成，是Hands Free所有平台的重要组成部分，可以应用于轮式机器人，人形机器人，平衡车，旋翼和固定翼的开发。 由于Hands Free建立了一个自己的机械，电路，嵌入式标准，所以Control Unit 还会支持Hands Free Team后续开发的软硬件。你既可以用这款控制器进行自主开发，也可以使用Hands Free嵌入式软件库OpenRE来开发，OpenRE提供了足够多的底层驱动代码和机器人代码库，以及代码的使用手册和测试案例，而且所有源码都是以BSD协议开源的。 关于OpenRE请看： https://github.com/HANDS-FREE/OpenRE 原理图 HandsFree ControlUnit V2 PCB正面和背面图 HandsFree ControlUnit V2 原理图part1 HandsFree ControlUnit V2 原理图part2 HandsFree ControlUnit V2 原理图part3 HandsFree ControlUnit V2 原理图part4 HandsFree ControlUnit V2 原理图part5 HandsFree ControlUnit V2 原理图part6 HandsFree ControlUnit V2 原理图part7 HandsFree ControlUnit V2 原理图part8 HandsFree ControlUnit V2 原理图part9 板载资源 HandsFree ControlUnit V2 正面图 HandsFree ControlUnit V2 背面图 关键特征 168MHZ STM32F407 Cortex M4 板载三轴陀螺仪，三轴加速计，气压计，三轴磁力计。 10PWM输入输出。 USBTTL, USB，microSD卡。 支持机型： 两轮平衡车，两轮差移动平台，三轮全向平台，四轮差速平台，四轮麦克纳姆轮全向平台，数字舵机人形，固定翼，四六八轴旋翼飞行器等。 处理器 32bit STM32F407 VGT6 Cortex M4 core with FPU 168MHZ 192KB SRAM 1M Flash 封装类型：LQFP, 引脚个数：100 板载传感器 MPU6050 6轴运动处理 ， 加速计陀螺仪。 MEAS MS5611高精度气压计。 3-轴数字罗盘IC HMC5883L 板载IC 大容量IIC快速存储器52KB EEPROM 专用ADC基准电压芯片LM4030A，电压采样精度高，可接固定翼用的空速计。 板载5V，3A大电流稳压IC。 集成CP2102 USB串口芯片。 集成VP230 CAN控制芯片。 集成三态门IC，用于数字舵机通信 板载多路电源保护器件，防反接，防过流，抵抗静电，支持多路USB和电源同时供电。 板载SBUS反相器电路，支持遥控器信号读取。 板载接口 四个电机控制以及编码器接口，支持常见类型的机器人平台控制。 10路PWM输出，可同时作为输入，用于搭建多轴飞行器或者舵机控制。 三路串口，USART2 UART4 USART6。 一路USB串口 USART1。 一个USB主从机接口。 一个microSD卡接口。 一路SBUS遥控器采集接口，用于采集航模遥控器的信号。 一路PPM遥控器采集接口，用于采集航模遥控器的信号，PPM接口还可用于扩展空速计。 一路数字舵机控制接口,支持AX12系列的数字舵机。 一个GPS接口，支持外部IIC陀螺仪和磁力计，兼容PX4接口。 一路CAN总线接口，可用于通信组网。 一路IIC接口，可用于扩展外部惯导传感器或者超声波等。 一路SPI接口。 除了以上，板载还有多个led显示，一个蜂鸣器，SWD烧写，复位电路等，电源电压采集电路等。 电源支持7~28V输入。 总结 HANDSFREE控制器，板载资源十分丰富，下料十足，可满足常见形态机器人研究需求，同时不惜成本，尽量选择稳定可靠的接口和IC，光是一个ADC基准电压的芯片就十几块钱，MOLEX接口也是选用昂贵的自锁接口，这主要是因为HANDSFREE团队本身也是使用这款控制器进行研究开发的，所以在很多细节方面考虑也是为了满足自己需求。 同时HANDSFREE团队为该控制器开发了OpenRE嵌入式机器人库，用户可以方便的在此库的基础上进行应用程序构建。而且OpenRE是还可以完全支持在linux环境下开发，这大大方便了ROS开发者和不懂嵌入式的机器人开发者。 使用说明 HandsFree ControlUnit V2 控制器是在第一代主控基础上发展而来一款多用控制器，不仅仅可以用于控制小车等地面移动平台，也可以用于飞行器的控制，在吸取第一代主控的优点不足的基础上进行改造，设计了自己的核心板，并且将众多传感器集成在核心板上，主控板支持7~12V的电源输入。 电路板使用教程链接 HandsFree mini Control Unit 使用手册 目录 简介 原理图 使用说明 板载资源 简介 Hands Free mini Control Unit 是Hands Free Team根据Hands Free开源项目的标准开发的一款的运动控制器，是Hands Free mini移动平台的重要组成部分。Hands Free mini移动平台是Hands free团队专为广大机器人学生爱好者开发的一款助学平台，价格低廉，性价比超高。麻雀虽小五脏俱全，Hands free mini移动平台同样可以用来进行移动导航和视觉开发。而Hands free mini Control Unit则是mini移动平台的核心部分，我们根据mini移动平台的特点将驱动集成在mini控制器上。同时增加了蓝牙模块和集成的MPU6050。 原理图 图1 HandsFree mini ControlUnit PCB正面和背面图 图2 HandsFree mini ControlUnit 原理图part1 图3 HandsFree mini ControlUnit 原理图part2 图4 HandsFree mini ControlUnit 原理图part3 图5 HandsFree mini ControlUnit 原理图part4 使用说明 图6 HandsFree mini ControlUnit 正面图 图7 HandsFree mini ControlUnit 背面图 HandsFree mini ControlUnit 控制器支持12V电源输入，同时允许转接电源。图6中电源输入口为黄色的xt60接口，同时带有两个12V电源转接口，允许转接到其他设备使用。HandsFree mini ControlUnit 控制器是专为HandsFree mini 移动平台量身打造的一款控制器。其功能齐全性价比超高，配合方便使用的嵌入式代码收到广大学生用户的喜爱。 mini控制板上设置一个电源开关，接通12V电源后按下开关主控器便开始工作，此时电源指示灯会变亮。控制板四周接有4个电机接口，两个串口，一个SPI接口，一个miniusb接口，一个SWD接口，一个can总线接口。同时控制板上集成了两块电机驱动，一块MPU6050，一个蓝牙，极大的方便了用户进行开发。 板载资源 STM32F103芯片 mpu6050加速计陀螺仪 4路电机控制接口：支持hands free team 开发的电机驱动，可用于搭载hands free 3wd轮式机器人或者hands free 2轮平衡车，hands free mini移动平台。 1路can总线：板载1个can接口，可用于通信，或者扩展hands free imu 高精度单轴陀螺仪 1路spi接口 1路双座USB母座接口：提供转接5V电源 2路串口接口： usart4 uart5 一个usb串口：采用ft232 usb 串口芯片 usart4，可usb线升级固件和通信 1个swd程序烧写接口 1个蓝牙 使用说明 电路板使用方式与V2一致 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 17:01:32 "},"docs/Hardware/Power-Manager.html":{"url":"docs/Hardware/Power-Manager.html","title":"Power Manager","keywords":"","body":"HandsFree Power Manager V2使用手册 目录 简介 供电方案 原理图 接口说明 简介    Hands Free Power Manager V2.0 是 Hands Free Team 根据 Hands Free 开源项目的硬件标准设计的一款电源分配板，附带多路开关和多种电源转换功能，满足机器人多样的电力需求。 支持常用的 TX1， TK1， MiniPC，树莓派， Kinect ，HOKUYOU 雷达等设备供电，同时还支持机器人的电机驱动， 云台舵机，机械臂等结构的供电，还自带一个急停开关接口和 1 一路急停电源输出。 配合大容量电池可以为机器提供集成供电方案。 供电方案    HandsFree 在中型及以上的移动平台上采用集成化的供电方案，这是为了简化机器人开发者对电源的设计同时方便开发者进行多种形式的开发。在电源板上有数量众多的电源接口，提供多种不同的电压，可以给各种形式的设备进行供电。同时我们定义了不同接口的所代表的不同电压，保证了不同的电压的设备和接口不能顺利连接在一起，从而保护设备。 图1         HandsFree 集成供电方案 原理图    为了满足开发者不同设备的所需的不同电压，我们将输入电压变压成12V、5V、19V，并提供足够大的驱动能力。12V输出部分最大可以有3A电流输出，5V电压部分最大可以有3A电流输出，19V电压部分最大可以有3A电流输出。我们定义了机器人驱动轮的电机电压为电池的输入电压。在HandsFree Power Manager V2电源管理板上允许输入的电压有12V和24V，这意味着可以去驱动12V和24V的电机，但是输入不同的电压需要做一些不同的处理。在输入12V电压时需要将板子中的12V/24V保险丝焊接起来（将24V转12V模块短路），同时需要把19V模块接成12V转19V模块。这样输出的电源电压为12V。在电池输入为24V时，12V/24V保险丝不需要焊接，同时19V模块接为24V转19V。 图2       HandsFree Power Manager V2 sch part 1 图3           HandsFree Power Manager V2 sch prat 2 图4           HandsFree Power Manager V2 sch prat 3 接口说明     电机接口和电源接口输出电压为电池电压，可以为12V或者24V，采用接口5557弯针插座。主控接口和12V电压输出的接口采用MX3.0mm间距2P连接器都是12V电压输出，主控的电压输出可以由主控开关控制。19V电压接口采用MX3.0mm间距2×2P连接器。19V电压输出由19V开关控制。5V的电压输出有两种接口，一种是5VUSB接口，另一种是5V舵机接口。5V的舵机接口采用XH2.54-3P 间距2.54MM 弯针插座。具体的接口位置在图5中可以看到。 图5          HandsFree Power Manager V2 接口说明 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 17:01:18 "},"docs/Hardware/Module.html":{"url":"docs/Hardware/Module.html","title":"Module","keywords":"","body":"HandsFree Motor Drive V2使用手册 目录 简介 原理图 使用说明 简介 HandsFree Motor Drive V2 是HandsFree Team根据Hands Free开源项目的标准开发的一款电机驱动器，是HandsFree开发的机器人Stone的硬件的组成部分之一。每块驱动板使用两块BTS7970芯片，可以驱动一个电机，保证足够大的驱动能力。同时能够将电源转接给其他驱动，极大的减少驱动电源线连接的复杂程度。第二代电机驱动板是在HandsFree Motor Driver_V1版本上优化而来，在保留了第一代版本的特点的同时新加了电流采样电路，因此不仅能够接收到更多的来控制电机，同时使得对电机的软保护成为了可能，有效的防止电机的堵转。另外还增加了防反接功能，杜绝了在错误连接时对驱动烧坏的可能。 原理图 图1    HandsFree Motor Driver V2 sch _ part1 图2    HandsFree Motor Driver V2 sch _ part2 图3    HandsFree Motor Driver V2 sch _ part3 图4    HandsFree Motor Driver V2 sch _ part4 使用说明 图5    HANDS FREE Driver V2 function 细节描述 驱动芯片：BTS7970 铜柱间距： 1220mil × 1690mil (40mil = 1mm) 3MM铜柱 板子大小： 1400mil × 1900mil 电流采样：0.34V/A Max: 输入电源大小：5~35V， 防反接保护。 输入接口： [电源输入接口][扩展电源接口][HANDSFREE标准电机接口] 输出接口： [电机接口] xh2.54mm 6P VCC5.0 GND 编码器AB相 焊盘*4 电机+ 电机焊盘 状态显示：[电机正反转 LED显示] [输入电源 LED显示][信号电源LED显示] 对于使用HANDSFREE接口电机的用户只需要把电机接上，控制接口连到主控就行，对于使用其他电机的用户，可以把电机和编码器的线焊接到驱动板的背面。 注意 BTS支持大功率电机驱动，但是由于电流采样电路只支持6A以内，所以若是使用大功率电机，可以通过去掉电流采样电路并加上金属散热片来实现，具体方法就是去掉R050这个0.5r的电阻，并把焊盘两端短路，同时去掉电解电容，在BTS上贴一个金属散热片。注意：如不进行此操作，直接驱动大功率电机可能会烧掉电流采样电阻。 HandsFree Remote 使用手册 简介 Hands Free Remote V2 是Hands Free Team根据Hands Free开源项目的硬件标准开发的一款遥控器，是Hands Free所有平台的组成部分，可以应用于轮式机器人，人形机器人，平衡车，旋翼和固定翼的开发。 由于Hands Free建立了一个自己的机械，电路，嵌入式标准，所以Remote 还会支持Hands Free Team后续开发的软硬件。你既可以用这款遥控器进行自主开发，也可以使用Hands Free嵌入式软件库OpenRE来开发，OpenRE提供了足够多的底层驱动代码和机器人代码库，以及代码的使用手册和测试案例，而且所有源码都是以BSD协议开源的。 关于OpenRE请看： OpenRE 实物图 图1 Remote正面 图2 Remote背面 电路图 图3 Remote电路图1 图4 Remote电路图2 图5 Remote电路图3 图6 Remote电路图4 板载资源 关键资源： 1、144MHZ STM32F103 Cortex M3 2、板载三轴陀螺仪，三轴加速度计 3、USBTTL 4、蓝牙4.0 处理器： 1、32bit STM32F103 RCT6 Cortex M3 core with FPU2、144 MHZ3、48KB SRAM 256KB Flash4、封装类型：LQFP， 引脚个数：64 板载传感器： 1、MPU6050 6轴运动处理，加速度计陀螺仪2、两个双通道摇杆，一个滑动变阻器 3、0.96寸OLED 板载接口： 1、一路串口，USART22、一路USB串口，UART43、两个双通道摇杆，一个滑动变阻器4、蓝牙4.05、除了以上，板载还有多个led显示，六个按键，一个蜂鸣器，SWD烧写，复位电路等，电源电压采集电路等6、电源支持2.5-5.5V输入 HandsFree Bluetooth_USART 简介 Hands Free Bluetooth_USART 是HandsFree Team根据Hands Free开源项目的硬件标准开发的一个串口转蓝牙模块。由于HandsFree建立了一个自己的机械，电路，嵌入式标准，所以Bluetooth_USART还会支持HandsFree Team后续开发的软硬件。 封装图 板载资源 蓝牙4.0芯片 led 3.3V稳压芯片 5针串口接口 HandsFree SWD 简介 Hands Free SWD 是Hands Free Team根据Hands Free开源项目的硬件标准开发的一个SWD转换模块。 实物图 图1 SWD正面 图2 SWD背面 Hands Free USBTTL 简介： Hands Free USBTTL 是Hands Free Team根据Hands Free开源项目的硬件标准开发的一个USB转串口模块。由于Hands Free建立了一个自己的机械，电路，嵌入式标准，所以USBTTL还会支持Hands Free Team后续开发的软硬件。 实物图： 图1 USBTTL正面 图2 USBTTL背面 电路图 图3 USBTTL电路图 板载资源： FT232RL芯片 三个LED USB micro接口 5针串口 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-15 14:58:36 "},"docs/Tutorial/":{"url":"docs/Tutorial/","title":"Beginner Tutorial","keywords":"","body":"Tutorial Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 17:06:23 "},"docs/Tutorial/1.1-Getting-Started.html":{"url":"docs/Tutorial/1.1-Getting-Started.html","title":"Getting Started","keywords":"","body":"本篇介绍OpenRE的安装和固件烧写。 请转至6.OpenRE Tutorials 提示： 请详细阅读6.1和6.2章节 介绍GUI的使用 接下来的章节讲解HANDS-FREE ROS端代码的使用。前提是你已经掌握ROS工作空间的建立、节点的编译等基本操作，并且HANDS-FREE ROS所需的依赖包已经安装完成（参考3.5 ROS环境 章节）。 HandsFree_ROS 源码的获取 我的ROS工作空间目录为~/catkin_ws,打开工作空间的src/目录，使用git clone 将HandsFree_ROS源码下载下来： cd ~/catkin_ws/src/git clone https://github.com/HANDS-FREE/handsfree.gitrospack profile 也可以直接在HANDS-FREE的github网站下载ZIP源码文件，然后解压到~/catkin_ws/src/目录。 修改配置文件的路径 将handsfree/handsfree_hw/src目录中的main.cpp文件第七行的路径/home/kedou/ros_workspace/HANDS_FREE_WS/src/handsfree_hw/config.txt改为自己的路径。 HandsFree_ROS 源码的编译 待源码下载好之后，接下来进行源码的编译： cd ~/catkin_wscatkin_make 注意： ROS Kinetic版本一定要在CmakeLists.txt里面加include_directories(${catkin_INCLUDE_DIRS})，否则报错ros/ros.h找不到。 当编译过程正常到达100%，没有出现任何错误时，HandsFree_ROS代码编译成功。 编译成功：同时要： source ~/catkin_ws/devel/setup.bash 否则会出现编译成功的包无法使用的情况，也可以将上面的命令放到~/.bashrc文件中，参考ROS Wiki。接下来就可以开始使用该包了。后面的章节将讲解以下功能的实现： 7.1 ROS遥控机器人 7.2 建图导航 7.3 RGBD测试 7.4 视觉跟踪 7.5 Gazebo仿真 7.6 头部跟踪 7.7 行为树 ROS安装 ROS的安装请参考ROS官网的相关教程：Ubuntu14.04 + ROS IndigoUbuntu16.04 + ROS Kinetic当ROS安装好后，安装ROS的教程包： sudo apt-get install ros--ros-tutorials 指ROS的版本（indigo，kinetic，etc），可以成功运行乌龟节点和键盘控制乌龟节点后再进行下一步。遥控乌龟： HANDSFREE依赖包的安装 为了保证HANDSFREE ROS端代码的正常运行，相关的依赖包的安装是必需的。参照《ROS by Example vol1》 和《ROS by Example vol2》两本书依赖包的安装，给出HANDSFREE相关依赖包的安装。 Indigo Version sudo apt-get install ros-indigo-turtlebot-bringup \\ros-indigo-turtlebot-create-desktop ros-indigo-openni-* \\ros-indigo-openni2-* ros-indigo-freenect-* ros-indigo-usb-cam \\ros-indigo-laser-* ros-indigo-hokuyo-node \\ros-indigo-audio-common gstreamer0.10-pocketsphinx \\ros-indigo-pocketsphinx ros-indigo-slam-gmapping \\ros-indigo-joystick-drivers python-rosinstall \\ros-indigo-orocos-kdl ros-indigo-python-orocos-kdl \\python-setuptools ros-indigo-dynamixel-motor-* \\libopencv-dev python-opencv ros-indigo-vision-opencv \\ros-indigo-depthimage-to-laserscan ros-indigo-arbotix-* \\ros-indigo-turtlebot-teleop ros-indigo-move-base \\ros-indigo-map-server ros-indigo-fake-localization \\ros-indigo-amcl git subversion mercurial sudo apt-get install ros-indigo-arbotix \\ros-indigo-dynamixel-motor ros-indigo-rosbridge-suite \\ros-indigo-mjpeg-server ros-indigo-rgbd-launch \\ros-indigo-openni-camera ros-indigo-moveit-full \\ros-indigo-turtlebot-* ros-indigo-kobuki-* ros-indigo-moveit-python \\python-pygraph python-pygraphviz python-easygui \\mini-httpd ros-indigo-laser-pipeline ros-indigo-ar-track-alvar \\ros-indigo-laser-filters ros-indigo-hokuyo-node \\ros-indigo-depthimage-to-laserscan ros-indigo-moveit-ikfast \\ros-indigo-gazebo-ros ros-indigo-gazebo-ros-pkgs \\ros-indigo-gazebo-msgs ros-indigo-gazebo-plugins \\ros-indigo-gazebo-ros-control ros-indigo-cmake-modules \\ros-indigo-kobuki-gazebo-plugins ros-indigo-kobuki-gazebo \\ros-indigo-smach ros-indigo-smach-ros ros-indigo-grasping-msgs \\ros-indigo-executive-smach ros-indigo-smach-viewer \\ros-indigo-robot-pose-publisher ros-indigo-tf2-web-republisher \\graphviz-dev libgraphviz-dev gv python-scipy 依赖包通过以上命令的安装，已经包含了键盘控制、计算机视觉、导航、建图、Ｇazebo仿真和机械臂控制等功能所需的依赖。　 Kinetic Version sudo apt-get install ros-kinetic-openni- ros-kinetic-openni2- ros-kinetic-freenect- ros-kinetic-usb-cam ros-kinetic-laser- ros-kinetic-hokuyo3d ros-kinetic-audio-common gstreamer0.10- ros-kinetic-slam-gmapping ros-kinetic-joystick-drivers ros-kinetic-orocos-kdl ros-kinetic-dynamixel-motor libopencv-dev python-opencv ros-kinetic-vision-opencv ros-kinetic-depthimage-to-laserscan ros-kinetic-turtlebot-teleop ros-kinetic-move-base ros-kinetic-map-server ros-kinetic-fake-localization ros-kinetic-amcl git subversion mercurial ros-kinetic-rosbridge-suite ros-kinetic-rgbd-launch ros-kinetic-openni-camera ros-kinetic-moveit ros-kinetic-turtlebot- ros-kinetic-kobuki-* python-pygraph python-pygraphviz python-easygui mini-httpd ros-kinetic-ar-track-alvar ros-kinetic-gazebo-ros ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-msgs ros-kinetic-gazebo-plugins ros-kinetic-gazebo-ros-control ros-kinetic-cmake-modules ros-kinetic-kobuki-gazebo-plugins ros-kinetic-kobuki-gazebo ros-kinetic-smach ros-kinetic-smach-ros ros-kinetic-grasping-msgs ros-kinetic-executive-smach ros-kinetic-smach-viewer ros-kinetic-robot-pose-publisher ros-kinetic-tf2-web-republisher graphviz-dev gv python-scipy Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 13:16:11 "},"docs/Tutorial/1.2-First-Experiment.html":{"url":"docs/Tutorial/1.2-First-Experiment.html","title":"First Experiment","keywords":"","body":"在上一章节讲到ROS的安装，以及为了使用HandsFree提供的ROS demo包如何安装相关的依赖包。并且上一章节提到使用ros--ros-tutorials包中小乌龟的键盘控制例程来测试ROS的基本组件是否正常工作。为了进一步测试安装的依赖包是否工作正常，我们将通过运行HansFree_ROS的键盘遥控机器人运动例程来测试。HandsFree的机器人嵌入式系统层和PC端ROS层是通过串口通讯按照自己制定的HFLink通讯协议进行通讯的。PC端和嵌入式层的通讯正常是机器人可以正常工作的前提条件。通讯正常时，嵌入式层可以将机器人的里程数据和坐标信息等返回至ROS中，同时ROS可以将目标速度数据、机械臂关节控制指令等数据下发至机器人嵌入式层来控制机器人的各个部分。通讯不正常的常见原因有： 串口线连接不正确 USB设备的权限不正确 主控固件刷写不正确 Ubuntu系统问题 波特率不匹配等 这些问题的分析与解决办法请参考6.1章节ROS遥控机器人的例程。 本章节讲解如何使用键盘遥控机器人进行移动。并且通过遥控机器人的测试我们可以验证ROS环境和HandsFree的环境是否配置正确、机器人嵌入式系统是否工作正常、机器人嵌入式系统层和PC端ROS层的通讯是否正常等问题。 第一步 通过PC的USB口和主控的USBTTL接口使用USB线将两者相连，请注意拔插线材时用力适度，防止损坏主控的USBTTL接口。确保主控正常上电，此时可以听到主控的蜂鸣器鸣叫声且LED灯持续闪烁。确保移动底盘的电路正常、电机和其驱动均连接正常。然后开始下一步操作。 第二步 在PC上打开一个新的终端，并运行： roslaunch handsfree_hw handsfree_hw.launch 该条命令打开了机器人抽象节点，该节点的作用是完成PC与机器人底层的通讯和相关指令与数据传输。运行结果如上图，图中有一个error，该error不影响后面的操作，可以忽略。确保没有其他问题，若出现timeout的问题，则说明该节点运行不成功。使用HANDSFREE的主控，出现timeout的几种常见原因和解决办法： 串口线没有插好或者PC端占用的COM口不是ttyUSB0 解决办法：检查串口线的连接。使用以下命令查看可用的USB设备号： ls /dev/ttyUSB* 若显示的USB设备不是ttyUSB0，则拔掉USB线重新插入PC，再次查看是否为ttyUSB0设备号。如果仍然不是，则修改handsfree/handsfree_hw/src目录中的main.cpp文件第七行的设备号\"serial:///dev/ttyUSB0\"为对应的设备号。 权限不够，由于ttyUSB0设备的权限不够，所以无法对其进行操作 解决办法: 使用以下命令修改ttyUSB0的权限： sudo chmod 777 /dev/ttyUSB0 主控板中的固件烧写不正确，由于版本差异等原因，固件烧写错误会导致通讯错误，出现timeout错误 解决办法: 根据移动底盘的型号、OpenRe的版本和Hnads-Free ROS代码的版本重新选择固件进行烧写。 Ubuntu系统的问题 此外，如果使用的不是HANDS-FREE的主控，出现了timeout的问题，除了上述四点原因外，可能是你所使用的USBTTL芯片不支持1M以上的波特率进行通讯，此时可以通过降低PC与主控通讯的波特率来进行解决，需要修改/handsfree/handsfree_hw/include/handsfree_hw/transport_serial.h文件中的波特率参数。当第二步没有问题时，说明硬件方面已正常，可以进行下一步了。 第三步 打开一个新的终端，并运行： roslaunch handsfree_hw keyboard_teleop.launch 该条命令打开键盘控制节点，利用键盘控制移动底盘运动。如果一切正常的话，你可以和移动ROS小乌龟一样，用键盘控制移动底盘运动了。 到此，完成ROS遥控机器人功能的实现，如果一切正常的话，说明移动底盘的软硬件没有问题，ROS端机器人抽象节点也没有问题，接下来就可以进行更高级功能的测试了。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 13:16:17 "},"docs/Tutorial/2.1-Mapping-Navigation.html":{"url":"docs/Tutorial/2.1-Mapping-Navigation.html","title":"Mapping & Navigation","keywords":"","body":"在实现导航功能之前需要对当前环境进行建图，在所下载的HandsFree_ROS包中所包含的地图是我们实验室的地图。所以你需要首先对你所在的环境使用激光雷达构建2维地图。 建图功能 1) 运行机器人抽象节点： roslaunch handsfree_hw handsfree_hw.launch 2) 运行激光节点如果使用rplidar： roslaunch rplidar_ros rplidar.launch 如果使用hokuyo: roslaunch handsfree_bringup hokuyo.launch 3) 运行建图节点： roslaunch handsfree_2dnav move_base_gmapping.launch 4) 利用RVIZ可视化建图过程 rosrun rviz rviz 打开RVIZ之后，手动选择handsfree/handsfree_2dnav/rviz/ HANDSFREE_Robot.rviz文件作为其配置文件。如果正常的话，可以在RVIZ中看到机器人模型及激光雷达扫描到的可视化数据。 5) 打开键盘控制节点： roslaunch handsfree_hw keyboard_teleop.launch 利用键盘遥控机器人在准备导航的环境中缓慢移动，使RVIZ中显示的地图逐渐补全，直到将整个环境的地图建好为止。当地图建好之后就要对地图进行保存。 6) 保存地图在你打算保存地图的目录运行下面的命令： rosrun map_server map_saver -f my_map 将生成两个文件.pgm和.yaml文件，建议将地图放在handsfree/handsfree_2dnav/map/目录下便于统一管理。到此，建图过程完成，下面进行导航功能的实现。最终生成的我们实验室的地图： 导航功能 1) 运行机器人抽象节点： roslaunch handsfree_hw handsfree_hw.launch 2) 运行激光节点如果使用rplidar： roslaunch rplidar_ros rplidar.launch 如果使用hokuyo: roslaunch handsfree_bringup hokuyo.launch 3) 运行导航节点：在运行前先对handsfree/handsfree_2dnav/launch/move_base_amcl_5cm.launch文件中的地图路径参数进行修改：将args=\"$(find handsfree_2dnav)/map/lab.yaml\"改为之前建好的地图的名称，保存更改。打开终端运行导航节点： roslaunch handsfree_2dnav move_base_amcl_5cm.launch 4) 利用RVIZ可视化导航过程 rosrun rviz rviz 打开RVIZ之后，手动选择handsfree/handsfree_2dnav/rviz/ HANDSFREE_Robot.rviz文件作为其配置文件。如果正常的话，可以在RVIZ中看到机器人模型及激光雷达扫描到的可视化数据。并且Global Options中的Fixed Frame选择map 5) 机器人初始位置的标定在RVIZ地图中看到的机器人位置可能并不是其当前的实际位置，为了机器人的自主定位和导航，我们需要为其手动标定其初始位置。使用RVIZ中的2D Pose Estimate手动标定其初始位姿，调整RVIZ中机器人的位置，让其尽量与实际位姿一致，然后进行导航功能。 6) 机器人导航功能实现使用RVIZ中的2D Nav Goal功能为机器人指定导航的目标点，如果一切正常的话，机器人将自主移动到所指定的目标点。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-16 13:11:02 "},"docs/Tutorial/2.2-RGBD-Test.html":{"url":"docs/Tutorial/2.2-RGBD-Test.html","title":"RGBD Test","keywords":"","body":"在3.5章节ROS Environment讲到ROS的安装，以及为了使用HandsFree提供的ROS demo包如何安装相关的依赖包。并且上一章节提到使用ros--ros-tutorials包中小乌龟的键盘控制例程来测试ROS的基本组件是否正常工作。为了进一步测试安装的依赖包是否工作正常，我们将通过运行HansFree_ROS的键盘遥控机器人运动例程来测试。HandsFree的机器人嵌入式系统层和PC端ROS层是通过串口通讯按照自己制定的HFLink通讯协议进行通讯的。PC端和嵌入式层的通讯正常是机器人可以正常工作的前提条件。通讯正常时，嵌入式层可以将机器人的里程数据和坐标信息等返回至ROS中，同时ROS可以将目标速度数据、机械臂关节控制指令等数据下发至机器人嵌入式层来控制机器人的各个部分。通讯不正常的常见原因有串口线连接不正确，USB设备的权限不正确，主控固件刷写不正确，Ubuntu系统问题和波特率不匹配等原因。这些问题的分析与解决办法请参考7.1章节ROS遥控机器人的例程。 RGBD Test 在7.2 Mapping Navigation章节建图时我们使用激光雷达扫描周围环境，提供距离数据从而生成地图。除了使用激光雷达进行建图，我们也可以使用深度摄像头模拟激光雷达进行建图。本章将讲解如何使用Asus Xtion进行建图。 测试Xtion是否工作正常 在3.5 ROS Environment章节配置HandsFree_ROS的依赖包时，安装过计算机视觉相关的包，其中包含了Asus Xtion的驱动程序。使用如下命令打开Xtion节点： roslaunch handsfree_bringup xtion.launch 上述命令的xtion.launch调用openni2_launch包中的launch文件打开Xtion节点，同时将深度标记参数设置为true,即开启Xtion的深度信息。如果出现如下WARNING： Warning: USB events thread - failed to set priority. This might cause loss of data... 不用担心，这个WARNING是正常的，可以忽略。然后在新的终端运行如下命令，分别可以查看RGB图像和深度图像： rosrun image_view image_view image:=/camera/rgb/image_rawrosrun image_view image_view image:=/camera/depth/image_raw 若RGB图像和深度图像都可以正常显示，则Xtion节点工作正常，也可以使用rqt工具查看xtion是否正常工作。在终端中输入rqt，打开rqt工具后，选择Plugins中Visaulization中的Image Viewer，然后选择对应的话题就可以查看RGB图像和深度图像了。 接下来进行建图。 RGBD 建图 使用深度摄像头建图和使用激光雷达进行建图的过程基本相同，只是将打开激光雷达节点更换为打开Xtion虚拟激光节点。相关命令如下： 1) 运行机器人抽象节点： roslaunch handsfree_hw handsfree_hw.launch 2) 运行Xtion虚拟激光节点 roslaunch handsfree_bringup xtion_fake_laser_openni2.launch 3) 运行建图节点： roslaunch handsfree_2dnav move_base_gmapping.launch 4) 利用RVIZ可视化建图过程 rosrun rviz rviz 打开RVIZ之后，手动选择handsfree/handsfree_2dnav/rviz/ HANDSFREE_Robot.rviz文件作为其配置文件。如果正常的话，可以在RVIZ中看到机器人模型及激光雷达扫描到的可视化数据。 5) 打开键盘控制节点： roslaunch handsfree_hw keyboard_teleop.launch 利用键盘遥控机器人在准备导航的环境中缓慢移动，使RVIZ中显示的地图逐渐补全，直到将整个环境的地图建好为止。当地图建好之后就要对地图进行保存。 6) 保存地图在你打算保存地图的目录运行下面的命令： rosrun map_server map_saver -f my_map 将生成两个文件.pgm和.yaml文件，建议将地图放在handsfree/handsfree_2dnav/map/目录下便于统一管理。到此，使用Xtion虚拟建图过程完成，之后可以使用保存的地图进行导航功能的实现。 Xtion虚拟激光与激光雷达建图的区别 Xtion虚拟激光扫描的角度相对较窄，Xtion一般在57°左右，而一般的激光雷达的扫描范围能达到240°甚至更大。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 13:27:47 "},"docs/Tutorial/2.3-Vision-Test.html":{"url":"docs/Tutorial/2.3-Vision-Test.html","title":"Vision Test","keywords":"","body":"在7.3 RGBD Test章节我们使用Xtion模拟激光雷达进行建图，在本章节将讲解使用Xtion和计算机视觉方法实现机器人跟踪二维码。 第一步 roslaunch handsfree_hw handsfree_hw.launch 打开机器人抽象节点，确保没有出现timeout的问题，如果出现该问题请参考7.1 Teleop章节进行解决。 第二步 roslaunch handsfree_bringup xtion.launch 打开Xtion驱动节点，将发布一系列RGB图像数据和深度图像数据。 第三步 使用RGB图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_rgb_camera.launch 或者使用深度图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_depth_camera.launch 上面两条命令二选一即可，它们都是使用开源的二维码识别库ar_track_alvar进行二维码的识别，ar_indiv_rgb_camera.launch和ar_indiv_depth_camera.launch文件的主要区别是订阅的话题不同，更多资料请参考ar_track_alvar的WIKI。 第四步 roslaunch handsfree_ar_tags ar_follower.launch 运行二维码跟踪器，其将根据二维码的识别结果控制机器人进行移动。将/handsfree/handsfree_ar_tags/config/Markers_0_2.png文件打印在纸上，将打印出的图案放置在Xtion摄像头前方，慢慢移动图案，机器人将跟随二维码图案位置的移动而运动。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-16 13:11:02 "},"docs/Tutorial/2.4-Simulation.html":{"url":"docs/Tutorial/2.4-Simulation.html","title":"Simulation","keywords":"","body":"Gazebo是一个功能十分强大的三维仿真软件，与ROS可以无缝连接进行机器人仿真。更多关于Gazebo的信息请参考Gazebo官网和ROS官网的Gazebo Wiki。本章讲解如何控制HandsFree的机器人模型在Gazebo的三维世界中进行移动。在安装ROS的时候一般已经默认安装了Gazebo，ROS Indigo默认安装Gazebo2.0版本，ROS Kinetic默认安装Gazebo7.0版本。在3.5 ROS Environment章节已经安装了连接ROS与Gazebo的依赖包。通过以下命令测试Gazebo是否能正常工作： roslaunch gazebo_ros empty_world.launch 如果能正常启动Gazebo，并且可以成功加载一个空白的世界模型，那就表示Gazebo可以正常工作。正常加载empty_world模型：此外，Gazebo对电脑显卡有一定要求，对Nvida显卡支持较好，对AMD的显卡支持较差，如果是AMD的显卡，复杂的世界模型一般加载不出来，例如下面的模型： roslaunch gazebo_ros willowgarage_world.launch 一般AMD的显卡可以启动Gazebo，但是界面是黑屏状态，无法加载模型。由于本章节的演示所加载的模型较简单，故对本章节要进行的仿真演示没有影响。下面进入正文。 添加驱动插件至机器人模型 在handsfree/handsfree_gazebo/urdf目录下是HandsFree的机器人模型文件，为了驱动机器人模型，使其在Gazebo中运动，我们需要向模型文件中添加驱动插件，添加如下内容至handsfree_base.xacro文件的上方： filename=\"libgazebo_ros_diff_drive.so\"> true 100 wheel_right_slipping wheel_left_slipping 0.36 0.06 10 cmd_vel odom odom base_link 0 上述添加的内容主要作用是表明使用差分方式驱动的轮子的标号，以及速度控制命令的话题是/cmd_vel,也就是说之后我们只要以/cmd_vel话题发布速度消息就可以控制机器人在Gazebo中运动了。关于上述内容的详细介绍请参考Gazebo官方教程。 然后使用如下命令打开Gazebo并加载HandsFree的机器人模型： roslaunch handsfree_gazebo handsfree_gazebo.launch 如果一切正常的话，可以在Gazebo的空白世界中看到HandsFree的Stone机器人模型。 发送速度消息 为了使机器人运动，我们需要以/cmd_vel话题发送速度消息，在此我们安装Teleop-twist-keyboard包来发送速度消息： sudo apt-get install ros-indigo-teleop-twist-keyboard 安装完成后使用如下命令打开发送界面： rosrun teleop_twist_keyboard teleop_twist_keyboard.py 打开后的界面与7.1 Teleop键盘遥控机器人运动的一样，使用i、，、j、l等键控制机器人在Gazebo中运动。到此完成控制机器人在Gazebo中运动，这只是一个简单的Gazebo例程，更多应用请参考Gazebo官方教程。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-16 13:11:02 "},"docs/Tutorial/2.5-Head-Tracking.html":{"url":"docs/Tutorial/2.5-Head-Tracking.html","title":"Head Tracking","keywords":"","body":"在7.4 Vision Demo演示了如何控制机器人跟踪二维码，本章将讲解如何控制机器人的头部Xtion跟踪二维码。HandFree机器人的头部是由二自由度云台构成，Xtion置于云台上，可以进行俯仰和偏转运动。云台由两个模拟舵机组成，确保舵机已正确连接至主控。实现头部跟踪的过程与7.4章节的过程类似。 第一步 roslaunch handsfree_hw handsfree_hw.launch 打开机器人抽象节点，确保没有出现timeout的问题，如果出现该问题请参考7.1 Teleop章节进行解决。 第二步 roslaunch handsfree_bringup xtion.launch 打开Xtion驱动节点，将发布一系列RGB图像数据和深度图像数据。 第三步 使用RGB图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_rgb_camera.launch 或者使用深度图像数据进行二维码识别： roslaunch handsfree_ar_tags ar_indiv_depth_camera.launch 上面两条命令二选一即可，它们都是使用开源的二维码识别库进行二维码的识别，ar_indiv_rgb_camera.launch和ar_indiv_depth_camera.launch的区别主要是订阅的话题不同，更多资料请参考ar_track_alvar的WIKI。 第四步 rosrun handsfree_ar_tags head_tracker.py 运行头部跟踪器，其将根据二维码的识别结果控制机器人的云台进行运动。将/handsfree/handsfree_ar_tags/config/Markers_0_2.png文件打印在纸上，将打印出的图案放置在Xtion摄像头前方，慢慢移动图案，机器人的头部将跟随二维码图案位置的移动而运动。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-15 19:35:30 "},"docs/Tutorial/Advanced/":{"url":"docs/Tutorial/Advanced/","title":"Advanced Tutorial","keywords":"","body":"Tutorial Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 17:06:23 "},"docs/Tutorial/Advanced/Behavior-tree/":{"url":"docs/Tutorial/Advanced/Behavior-tree/","title":"Behavior Tree","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-03 19:34:08 "},"docs/Tutorial/Advanced/Object-Recognition/":{"url":"docs/Tutorial/Advanced/Object-Recognition/","title":"Object Recognition","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-08 23:01:00 "},"docs/Tutorial/Advanced/Person-Follower/":{"url":"docs/Tutorial/Advanced/Person-Follower/","title":"Person Follower","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-08 23:01:00 "},"docs/Tutorial/Advanced/Object-Pick-Place/":{"url":"docs/Tutorial/Advanced/Object-Pick-Place/","title":"Object Pick Place","keywords":"","body":"一、前言 HandsFree团队在其最新的Giraffe移动机器人平台上使用了HF中型机械臂，其设计原型来自于西工大舞蹈机器人基地家政组晓萌机器人的老机械臂。作为之前负责过晓萌机械臂软件部分的队员，我把自己曾经开发机械臂时所总结的一些方法和及经验分享出来，当然，写得不对的地方欢迎各位大神指正，也欢迎正在研究机械臂的大神能在此留下自己宝贵的开发经验。 二、技术介绍 机械臂作为机器人最为重要的执行器，赋予了机器人与外部世界环境进行物理交互的能力。这使得机器人的智能不仅仅停留在识别和规划层上，还能通过实际的操作将其真正的表达出来。目前国内外机械臂研究的热点主要集中在机械臂自主精确抓取、放置物体上，而根据本人之前的开发经历，要想让机械臂能完美地执行一系列复杂且精确的操作从而使末端执行器到达预定的位置是很难的，这需要我们理解并掌握很多与机械臂解算相关的数学知识。我相信这会让很多非专业开发者感到头疼，不过借助于第三方开源软件，比如ROS和MoveIT！机械臂的开发就会相对来说简单很多。下面，我分机械、电子和软件三个方面，详细地讲解一下自己在开发过程中所总结的一些技术要点。最后，你可以在开发代码（在ROS Indigo下能成功编译并运行，不支持ROS Kinetic）和问题汇总中找到我之前整理的相关资料。 1、机械 我们机器人的机械臂在机械设计上有一些不一样的地方。相比于其他使用大扭矩舵机或电机作为关节的机械臂，我们使用了由同步轮和同步带所组成的机械结构，这种独特的结构使得我们的机械臂在一定程度上拥有了抓取更重物体的负载能力。除此之外，机械臂末端的手爪也由上一代的对称张开闭合的结构变成了平行夹紧的形式，即两个金属滑块可以通过在滑轨上对称平行的移动。这使得手爪可以适应不同粗细、形状的物体，为抓紧物体提供最基本的保障。当然，这个机械臂也曾经给我造成过一些小困扰，我会在下面的软件部分讲到，通过这个困扰的解决，你就可以理解为什么机械的设计在某种程度上会影响软件代码的编写。 2、电子 电子部分作为连接机械臂软硬件的重要组成部分，主要的任务是负责将软件组通过RS-485传过来的数据进行解析，并且以最快的速度传递给接有驱动盒的电机来实时地控制机械臂。同样的，通过电机编码器返回的数据可以用来记录每个机械臂关节的实时状态，经过一定的数学解算，就可以将其作为运动规划层的输入，为复杂运动的规划提供基本的保证。机械臂控制使用的是位置闭环算法，具体这方面我了解的并不是很多，不过之前用起来还是很稳定的。 3、软件 从软件架构图中可以很清楚的看到，机械臂的软件层主要由三个部分组成，从下到上依次为：硬件接口层、运动规划层和任务决策层。 (1)、硬件接口层 机械臂硬件接口层的设计理念来源于ROS Control。ROS Control是ROS提供的软件与硬件之间进行数据通信的中间件，它对硬件进行了抽象，统一了数据通信的接口，并通过插件的形式封装了一些常用的运动控制算法，为建立机器人软硬件模块之间的数据通路提供了便捷。 ROS Control提供的硬件抽象层主要负责管理机器人的硬件资源，而控制器从抽象层请求资源即可，并不直接接触硬件。这提高了代码的复用率和可移植性。 首先，让我们先看一下ROS Control官方提供的数据流图是什么样子的： 细心的读者可能会发现这两个架构图在硬件接口层部分有一些不一样的地方。接下来我就讲解一下硬件接口层部分各子模块的功能，并解释彼此不同的原因。 实体机械臂： 这一部分指的就是真实客观存在的机械臂。STM32嵌入式控制器使用位置PID闭环算法来计算由硬件抽象层通过串口通信方式发过来的关节数据，并将计算好的数据直接发送给电机对其进行控制。同时，电机的编码器也将电机实时的位置数据经串口通信返回给上面的硬件抽象层。 硬件抽象层： 硬件抽象层和硬件直接打交道，通过write和read方法来完成对硬件的相关操作。硬件抽象层跟上面官方提供（红色的部分）的有一些不太一样的地方在于我并没有使用ROS Control提供的Transmissions（数据转换）和Joint Limits(关节限位）的API。原因的话，我在下面会讲到。这首先简要的介绍一下什么是Transmissions和Joint Limits。 Transmissions： Transmissions就是机器人每个运动关节和电机之间的数学映射。因为机械臂关节结构的不同，会导致机器人上层规划所使用的Joint与Actuator数据之间存在明显的偏差。比如说有简单齿轮和同步带驱动的，有锥齿轮差动机构，四连杆机构等。Transmissions提供的接口中包含有解决上面这些结构进行数据转换的映射公式。 Joint Limits： Joint Limits主要是维护了一个关节限位的数据结构，里面可以包含的数据种类不仅仅是常用的关节位置、速度、力矩、加速度等方面的限位，还可以储存具有安全作用的位置软限位、位置边界和速度边界等。 至于我为什么没有使用以上两个模块的原因，主要是参考了西工大一小学生曾经在Exbot上发表的有关ROS Control的文章。下面就截取其中的一小部分： 以上两个模块是因为URDF中有相应的标签，写了一堆可以直接Load的，但是实际用处并不是很大。它的设计思想是想在URDF中表示更多的信息，这些信息在Gazebo中可以给出更多的细节。但是解析URDF的程序使得RobotHW体量很大，而且这些细节会因为机器人本体通讯暴露给ROS的细节量而不尽相同，而且还会显著提高编程复杂度，所以这些信息显得冗余，而应用这些信息的库也就显得冗余。 之前，我是有尝试过在RobotHW中加载URDF中的相关标签，不过用起来确实就如同小学生所说的那样，比较麻烦，而且还很冗余。因此，我根据机械组队员提供的有关机械臂关节电机转换的数学公式封装了相应的函数，至于Joint Limits，我是在规划层的地方进行了指定。 控制器管理器： 控制器管理器提供一种通用的接口来管理不同的ROS Controllers，它可以加载、开始运行、停止运行、卸载不同的Controller，并且提供了多种工具来完成这些操作。Controller Manager的输入就是ROS上层应用的输出。在这里面，我用到了Joint Command Controller和Joint State Controller，它们分别可以完成对每个关节的控制以及读取硬件接口中关节的状态。 好的。前面讲了很多新的概念，这里我们还是找个案例来具体的分析一下。这里，以我之前整理的源码作为参考，分析一下机械臂分别在Gazebo仿真和物理物理环境中是如何体现上面那些概念的。 首先看一张来自Gazebo官网的ROS Control架构图： 从图中可以看到，Simulation和Hardware之上的Hardware Resource和Controller Manager是一样的，这很清晰地体现了ROS Control的底层无关性，即无论使用的是抽象的仿真还是具体的硬件，只要程序能继承RobotHW硬件抽象层的基类来做到数据接口的统一，Controller Manager就可以对相应的资源进行管理。 对于Simulation和Hardware来说，它们内部架构相似，但配置以及使用方式是不一样的。Simulation的RobotHW部分，Gazebo官方已经将其实现，并且提供了相应的ROS Control插件来从机械臂的URDF文件中载入所需的数据。用户只需写好URDF和YAML文件，并使用ROS Launch将其整合到一起就万事大吉了。 而对于Hardware这部分来说，除了上面说到的配置之外，我们还需要自己编写C++代码来继承RobotHW基类，并在里面分别使用命令和状态硬件接口句柄对相应的关节数据进行注册，然后再将不同的硬件接口注册到RobotHW上。最后，我们还要自己编写函数完成对关节和电机数据的相互转换，并且根据指定的通信协议，实现read和write函数。 仿真部分： xm_arm_description/gazebo/xm_arm_gazebo_transmission.xacro 每个关节都添加了Hardware Interface，并且在具有父子关系的两个关节之间添加了对应的Transmission。 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 transmission_interface/SimpleTransmission PositionJointInterface PositionJointInterface 1 xm_arm_description/gazebo/xm_gazebo_ros_control.xacro 为了让Gazebo可以识别Transmission标签，需要添加Gazebo的ROS Control插件。 /xm_arm gazebo_ros_control/DefaultRobotHWSim xm_arm_gazebo_controller_config/xm_arm_gazebo_joint_position.yaml 使用YAML格式的文件来声明我们所需要使用的Controller，以及对应的参数。 xm_arm: # Position Controllers joint_lift_position_controller: type: position_controllers/JointPositionController joint: joint_lift pid: {p: 100.0, i: 0.01, d: 10.0} joint_waist_position_controller: type: position_controllers/JointPositionController joint: joint_waist pid: {p: 100.0, i: 0.01, d: 10.0} joint_big_arm_position_controller: type: position_controllers/JointPositionController joint: joint_big_arm pid: {p: 100.0, i: 0.01, d: 10.0} joint_forearm_position_controller: type: position_controllers/JointPositionController joint: joint_forearm pid: {p: 100.0, i: 0.01, d: 10.0} joint_wrist_pitching_position_controller: type: position_controllers/JointPositionController joint: joint_wrist_pitching pid: {p: 100.0, i: 0.01, d: 10.0} joint_wrist_rotation_position_controller: type: position_controllers/JointPositionController joint: joint_wrist_rotation pid: {p: 100.0, i: 0.01, d: 10.0} joint_finger_left_position_controller: type: position_controllers/JointPositionController joint: joint_finger_left pid: {p: 100.0, i: 0.01, d: 10.0} joint_finger_right_position_controller: type: position_controllers/JointPositionController joint: joint_finger_right pid: {p: 100.0, i: 0.01, d: 10.0} xm_arm_gazebo_controller_config/xm_arm_gazebo_joint_states.yaml 使用Joint State Controller来发布每个关节的实时状态。 xm_arm: # Publish all joint states joint_state_controller: type: joint_state_controller/JointStateController publish_rate: 50 xm_arm_bringup/launch/xm_arm_bringup_gazebo_joint_control.launch 最后编写Launch文件来启动Controller Manager中的Spawner，加载上述插件。并启动Gazebo和Rviz载入相关的机械臂模型。 在终端中输入以下命令启动Motion Control测试。 $> roslaunch xm_arm_bringup xm_arm_bringup_gazebo_joint_control.launch $> rosrun xm_arm_teleop xm_arm_teleop_position_keyboard 你可以使用键盘上的按键来控制机械臂每个关节的移动位置。 硬件部分： xm_arm_robot_hardware/include/xm_arm_robot_hardware/xm_arm_robot_hardware.h 创建子类继承RobotHW父类，并且声明了一些函数和变量。 class ArmRobotHardware : public hardware_interface::RobotHW { public: ArmRobotHardware(ros::NodeHandle nh); ~ArmRobotHardware(); ros::Time getTime(); ros::Duration getPeriod(); ros::CallbackQueue* getCallbackQueue(); void read(const ros::Time, const ros::Duration period); void write(const ros::Time, const ros::Duration period); bool start(); void stop(); double getFreq() const; private: void publishArmCommand(const u_int8_t func, const u_int8_t jnt_id, const float jnt_pos); void publishArmJState(const u_int8_t func, const u_int8_t jnt_id); void getArmStateCallback( const xm_arm_msgs::xm_ArmSerialDatagram::ConstPtr& msg); void getArmStatusCallback( const xm_arm_msgs::xm_ArmSerialDatagram::ConstPtr& msg); bool checkArmStatus(); void transPositionJointToActuator(); void transPositionActuatorToJoint(); private: ros::NodeHandle nh_; ros::CallbackQueue callback_queue_; ros::Publisher arm_serial_pub_; ros::Subscriber arm_state_sub_; ros::Subscriber arm_status_sub_; int arm_command_id_; int arm_state_id_; double freq_; hardware_interface::JointStateInterface jnt_state_interfece_; hardware_interface::PositionJointInterface jnt_position_interface_; hardware_interface::VelocityJointInterface jnt_velocity_interface_; std::vector jnt_name_; std::vector act_name_; std::map jnt_pos_; std::map jnt_vel_; std::map jnt_eff_; std::map act_pos_; std::map jnt_cmd_; std::map act_cmd_; std::vector jnt_stamp_; enum HARDWARE_STATUS {UNKNOWN, READY, RUNNING, ERROR}; std::vector jnt_status_; }; xm_arm_robot_hardware/src/xm_arm_robot_hardware.cpp 初始化关节和电机数据，并使用Hardware Interface对相应的数据进行注册，最后初始化与串口通信有关的Topic。 ArmRobotHardware::ArmRobotHardware(ros::NodeHandle nh) : nh_(nh), freq_(20) { nh_.setCallbackQueue(&callback_queue_); jnt_name_.push_back(\"joint_lift\"); jnt_name_.push_back(\"joint_waist\"); jnt_name_.push_back(\"joint_big_arm\"); jnt_name_.push_back(\"joint_forearm\"); jnt_name_.push_back(\"joint_wrist_pitching\"); jnt_name_.push_back(\"joint_wrist_rotation\"); act_name_.push_back(\"actuator_lift\"); act_name_.push_back(\"actuator_waist\"); act_name_.push_back(\"actuator_big_arm\"); act_name_.push_back(\"actuator_forearm\"); act_name_.push_back(\"actuator_wrist_left\"); act_name_.push_back(\"actuator_wrist_right\"); for (int i = 0; i ( \"xm_arm_serial/send_arm_command\", 1000); arm_state_sub_ = nh_.subscribe(\"xm_arm_serial/receive_arm_state\", 1000, &ArmRobotHardware::getArmStateCallback, this); arm_status_sub_ = nh_.subscribe(\"xm_arm_serial/receive_arm_status\", 1000, &ArmRobotHardware::getArmStatusCallback, this); } 根据机械臂公式，实现关节和电机数据之间的互相转换。 void ArmRobotHardware::transPositionJointToActuator() { act_cmd_[\"actuator_lift\"] = -jnt_cmd_[\"joint_lift\"] * 100; act_cmd_[\"actuator_waist\"] = jnt_cmd_[\"joint_waist\"]; act_cmd_[\"actuator_big_arm\"] = -jnt_cmd_[\"joint_big_arm\"] * 1.6667; act_cmd_[\"actuator_forearm\"] = -jnt_cmd_[\"joint_forearm\"] + jnt_cmd_[\"joint_big_arm\"] * 1.6667; act_cmd_[\"actuator_wrist_left\"] = -(-jnt_cmd_[\"joint_big_arm\"] * 1.6667 + jnt_cmd_[\"joint_forearm\"] * 1.6000 + jnt_cmd_[\"joint_wrist_pitching\"]) * 0.6250 + jnt_cmd_[\"joint_wrist_rotation\"] * 0.7917; act_cmd_[\"actuator_wrist_right\"] = -(-jnt_cmd_[\"joint_big_arm\"] * 1.6667 + jnt_cmd_[\"joint_forearm\"] * 1.6000 + jnt_cmd_[\"joint_wrist_pitching\"]) * 0.6250 - jnt_cmd_[\"joint_wrist_rotation\"] * 0.7917; } // Because autuator's direction is not unified, the signs of positive and // negative may have problem in the following formula. void ArmRobotHardware::transPositionActuatorToJoint() { jnt_pos_[\"joint_lift\"] = -act_pos_[\"actuator_lift\"] * 0.010; jnt_pos_[\"joint_waist\"] = act_pos_[\"actuator_waist\"]; jnt_pos_[\"joint_big_arm\"] = -act_pos_[\"actuator_big_arm\"] * 0.600; jnt_pos_[\"joint_forearm\"] = -(act_pos_[\"actuator_forearm\"] + act_pos_[\"actuator_big_arm\"]); jnt_pos_[\"joint_wrist_pitching\"] = -(-act_pos_[\"actuator_big_arm\"] * 0.6400 - act_pos_[\"actuator_forearm\"] * 1.6000 + (act_pos_[\"actuator_wrist_left\"] + act_pos_[\"actuator_wrist_right\"]) * 0.8000); jnt_pos_[\"joint_wrist_rotation\"] = (act_pos_[\"actuator_wrist_left\"] - act_pos_[\"actuator_wrist_right\"]) * 0.6316; } 实现定制的read和write函数。 void ArmRobotHardware::read(const ros::Time, const ros::Duration period) { for (size_t i = 0; i 0.5) { ROS_WARN_STREAM(\"Reading timeout!\"); return ; } } } void ArmRobotHardware::write(const ros::Time, const ros::Duration period) { transPositionJointToActuator(); for (size_t i = 0; i 0.5) { ROS_WARN_STREAM(\"Writing timeout!\"); return ; } } } xm_arm_hardware_controller_config/config/xm_arm_hardware_joint_trajectory.yaml Joint Trajectory Controller可以提供经过时间差值的连续关节轨迹，是MoveIT!中默认的数据接口。 xm_arm: arm_controller: type: \"position_controllers/JointTrajectoryController\" joints: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation xm_arm_hardware_controller_config/config/xm_arm_hardware_joint_states.yaml 这个与上面所仿真使用的Controller是一样的。 xm_arm: joint_state_controller: type: joint_state_controller/JointStateController publish_rate: 50 xm_arm_hardware_controller_config/config/xm_arm_hardware_joint_names.yaml 加载关节名字到ROS的参数服务器中。 xm_arm: joint_names: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation 以上就是硬件接口层的全部内容了。作为整个机械臂软件架构最底层的部分，它的重要性不言而喻。根据我之前开发机械臂的经验，只有编写出稳定且鲁棒的的硬件接口层，才能为之上的运动规划提供强有力的保证。否则，等到机械臂出现暴走失控的情况的时候就麻烦了（我之前就曾入过这样的坑！）。 (2)、运动规划层 运动规划层在机械臂的自主抓取中扮演了非常重要的角色。而对于运动规划本身来说，里面涉及了非常多的专业知识，比如运动学正逆解算、碰撞检测算法、3D环境感知、动作规划算法等，以上任何一个方面都需要我们长时间的积累才能理解清楚，而对于那些想立马上手机械臂的初学者来说，这简直就是一个灾难。 而幸运的是，ROS提供了强大且易用的MoveIt!包，它可以让你在较短的时间内实现仿真乃至实体机械臂的运动学规划演示。 首先，简要地介绍一下什么是MoveIt!。以下是MoveIt官网给出的定义： MoveIt! is state of the art software for mobile manipulation, incorporating the latest advances in motion planning, manipulation, 3D perception, kinematics, control and navigation. It provides an easy-to-use platform for developing advanced robotics applications, evaluating new robot designs and building integrated robotics products for industrial, commercial, R&D and other domains. 概括来说，MoveIt!是ROS中与移动操作相关的组件包的集合。它包含了运动规划、操作控制、3D感知，运动学，碰撞检测等。当然，最重要的是MoveIt!提供了非常友好的配置和调试界面。 下图是MoveIt的总体框架： 这张图我在学习MoveIt!的时候看过很多遍，理解这个架构图对于学习MoveIt!非常重要。从图中可以看到，move_group是MoveIt!最核心的部分。它将其他独立的组件集成到一起，为使用者提供了一系列可以使用的命令和服务。 用户接口： 用户可以使用C++、Python或者GUI来访问move_group。一般对于初学者来说，GUI和Python的使用会更多一些。 配置： move_group本质上还是一个ROS的节点，它需要使用ROS的参数服务器来获取以下三种信息。 URDF： move_group需要机械臂的URDF文件来进行运动规划。 SRDF： move_group在启动时会寻找机械臂的SRDF文件，它可以通过使用MoveIt! Setup Assistant自动生成。 MoveIt!配置： move_group在启动时会加载机械臂的关节限位、动力学、运动规划、感知以及其他相关信息。所有以上的配置信息都可以通过使用MoveIt! Setup Assistant自动生成。 机器人接口： move_group使用ROS中的Topic和Action两种机制来与机械臂进行数据通信。它可以获取当前机械臂的位置信息，点云数据以及其他传感器数据，并且发送命令给机械臂的Controller。 关节状态信息： move_group会监听机械臂的/joint_states主题来获取当前的状态信息。注意：move_group只管监听，你需要自己给机械臂配置好Joint State Controller。 坐标转换信息： move_group可以订阅机械臂的TF主题来确定机械臂内部各关节之间的位置变换关系。跟上面一样，你需要自己运行Robot State Publier节点来发布坐标转换。 控制器接口： move_group使用Follow Joint Trajectory类型的Action接口来与Controller进行数据通信。move_group自己是不带Action接口的，它是使用了一个特殊的插件来发布上述Follow Joint Trajectory类型的Action，而对于机械臂来说，你依然需要自己配置上述类型的Controller来订阅机械臂的数据。 规划场景： Planning Scene指的是机械臂本身以及其周围环境的表示。 扩展能力： move_group的所有组件都是以独立插件的形式实现的，而且这些插件可以通过使用ROS的参数文件或插件库来进行配置，这使得move_group拥有了强大的定制以及可扩展能力。 接下来，我们介绍一下Motion Planning。 这里我引用古月居前辈对运动规划的解释： 假设我们已知机器人的初始姿态和目标姿态，以及机器人和环境的模型参数，那么我们就可以通过一定的算法，在躲避环境障碍物和放置自身碰撞的同时，找到一条到达目标姿态的较优路径，这种算法就称为机器人的运动规划。机器人和环境的模型静态参数由URDF文件提供，在默写场景下还需要加入3D摄像头、激光雷达来动态检测环境变化，避免与动态障碍物发生碰撞。 在MoveIt!中，运动规划算法是由运动规划器算出来的。当然，运动规划算法有很多，每一个运动规划器都是MoveIt的一个插件，可以根据需求选用不同的规划算法。MoveIt!默认使用的是OMPL。OMPL(Open Motion Planning Library)是开源运动规划库的简写，它提供基于随机化的运动规划器。 运动规划请求： 在让运动规划器进行运动规划之前，我们要先发送一个运动规划的请求。这个请求可以是新的机械臂或末端执行器的位置。为了让运动规划器规划出来的轨迹符合要求，我们需要指定一些约束条件： 位置约束： 约束机械臂Link的位置。 方向约束： 约束机械臂Link的方向。 可见性约束： 约束Link上的某点在某些区域的可见性。 关节约束： 约束Joint的运动范围。 自定义约束： 使用自定义的回调函数来指定约束条件。 运动规划结果： move_group节点最终将会根据上面的运动规划请求，生成一条运动轨迹。这条轨迹可以使机械臂移动到预想的目标位置。请注意：move_group输出的是一条轨迹，而不是路径。对于机械臂来说，路径是使末端执行器移动到目标位置的过程中，中间所经历的一系列独立的位置点。而轨迹则是在路径的基础上，通过加入速度、加速度约束以及时间参数来使机械臂运动的更加平滑。 规划请求适配器： 在运动规划器的输入输出端分别有两个规划请求适配器。它们的作用分别是对规划请求和规划结果进行预处理和后期处理。MoveIt!提供了几种默认的适配器来完成一些特定的功能。 FixStartStateBounds: 当机械臂的一个或多个关节的初始状态稍微超出了URDF文件中所定义的Joint Limits后，为了能让运动规划器可以运行，FixStartStateBounds适配器会通过将关节状态移动到Joint Limits处来解决这个问题。不过，如果机械臂关节的偏差很大的话，这种靠软件方式修正的方式就不适用了。 FixWorkspaceBounds: 这个适配器会默认地生成一个10x10x10立方米的机械臂规划空间。 FixStartStateCollision: 如果已有的关节配置文件会导致碰撞，这个适配器可以采样新的配置文件，并根据摇摆因子来修改已有的配置文件，从而保证新的机械臂不会发生碰撞。 FixStartStatePathConstraints: 如果机械臂的初始姿态不满足路径约束，这个适配器可以找到附近满足约束的姿态作为机械臂的初始姿态。 AddTimeParameterization: 这个适配器非常重要。它把从运动规划器中输出的空间路径按等距离进行划分，并在其中添加加速度、加速度约束，以及时间戳等必要信息。 Planning Scene Planning Scene用来表示机械臂周围的外部世界并且保存机械臂自己本身的状态。它通过监听对应的Topic来获取关节状态信息、传感器信息。并可以根据传感器信息和用户的输入，生成机器人周围3D世界空间的表示。 3D Perception 简单来说，3D Perception使用插件来获取点云和深度图像数据，并据此生成OctoMap，为之后机械臂的碰撞检测提供基础。 Kinematics 运动学算法是机械臂各种算法中的核心，尤其是反向运动学算法IK(Inverse Kinematics)。MoveIt!使用插件的形式可以让用户灵活的选择需要使用的反向运动学算法，也可以选择自己的算法。 Collision Checking MoveIt!使用CollisionWorld对象进行碰撞检测，采用FCL(Flexible Collision Library)功能包。碰撞检测是运动规划中最耗时的运算，往往会占用90%左右的时间，为了减少计算量，可以通过设置ACM(Allowed Collision Matrix)来进行优化。 好的，讲了这么多抽象的概念，就让我们像上一节讲ROS Control一样，用具体的例子来实践一下。 首先，你需要机械臂的URDF文件，而且保证里面所包含的Link(连杆)、Joint(关节)、运动学参数、动力学参数、可视化和碰撞模型没有问题。这里要注意一下，通过SolidWorks插件导出的URDF文件，它默认使用的碰撞检测模型和可视化模型是一样的。为了提高运动规划的执行速度，你可以使用MeshLab来简化模型（.stl或.dae零件）的点和面。 xm_arm_description/urdf/xmbot_with_arm.urdf.xacro 之后，运行下面命令来启动MoveIt! Setup Assistant。 rosrun moveit_setup_assistant moveit_setup_assistant 之后你可以根据MoveIt! Setaup Assistant官网教程完成机械臂的配置。虽然这里我没有详细讲解配置的每一步（其实是我忘了截图），但这一步是非常重要的。我之前就配置过很多次，但总有问题。所以说配置机械臂MoveIt!参数是需要一定经验的。这里，我主要讲两个我在配置过程中遇到的问题，希望对你有所帮助。 交互式Marker没有在末端执行器上生成： 这个问题曾经困扰了我很久，后来我在Google上搜索了一段时间，终于找到问题的原因和解决办法。出现这个问题的原因是我在配置末端执行器的时候，parent_link没有选择arm组中的link，而是选了gripper组中的。因此，解决办法就是选择arm组中的最顶端的link填入到parent_link中就没问题了。 MoveIt!根据点云数据生成的OctoMap在Rviz中的位置、方向与实际不符： 这个问题的原因，你可以通过可视化Rviz中的TF插件来看到。每个Link都有自己的XYZ方向，如果你机器人的Camera Link的XYZ方向恰好与Rviz所使用的XYZ方向不符，就会出现上述问题。我的解决办法是在URDF中再添加一个或两个虚拟的Link来修正方向上的偏差。 打开用MoveIt! Setup Assistant生成的包，我们可以发现里面有config和launch两个文件夹。这里简要介绍下每个文件的功能。 xm_arm_moveit_config/config/controllers.yaml 这个文件指定了MoveIt!向Controller发布数据的接口。注意：这个配置文件不是用MoveIt! Setup Assistant自动生成的，你需要自己添加。而且name要与Controller配置文件的namespace保持一致。否则，MoveIt!输出的轨迹是没法传送给物理机械臂的。 controller_list: - name: xm_arm/arm_controller action_ns: follow_joint_trajectory type: FollowJointTrajectory default: true joints: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation xm_arm_moveit_config/config/fake_controllers.yaml 这是虚拟控制器配置文件，方便我们在没有实体机械臂，甚至没有任何模拟器开启的情况下也能运行MoveIt!。 controller_list: - name: fake_xm_arm_controller joints: - joint_lift - joint_waist - joint_big_arm - joint_forearm - joint_wrist_pitching - joint_wrist_rotation - name: fake_xm_gripper_controller joints: - joint_finger_left - joint_finger_right xm_arm_moveit_config/config/joint_limits.yaml 这里记录了机械臂各关节的位置、速度、加速度的极限。 # joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] joint_limits: joint_big_arm: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_finger_left: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_finger_right: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_forearm: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_lift: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_waist: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_wrist_pitching: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 joint_wrist_rotation: has_velocity_limits: true max_velocity: 1 has_acceleration_limits: false max_acceleration: 0 xm_arm_moveit_config/config/kinematics.yaml 记录运动规划的配置参数。 xm_arm: kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin kinematics_solver_search_resolution: 0.005 kinematics_solver_timeout: 0.05 kinematics_solver_attempts: 3 xm_arm_moveit_config/config/ompl_planning.yaml 记录了OMPL算法的各种配置参数。 planner_configs: SBLkConfigDefault: type: geometric::SBL range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() ESTkConfigDefault: type: geometric::EST range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0 setup() goal_bias: 0.05 # When close to goal select goal, with this probability. default: 0.05 LBKPIECEkConfigDefault: type: geometric::LBKPIECE range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() border_fraction: 0.9 # Fraction of time focused on boarder default: 0.9 min_valid_path_fraction: 0.5 # Accept partially valid moves above fraction. default: 0.5 BKPIECEkConfigDefault: type: geometric::BKPIECE range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() border_fraction: 0.9 # Fraction of time focused on boarder default: 0.9 failed_expansion_score_factor: 0.5 # When extending motion fails, scale score by factor. default: 0.5 min_valid_path_fraction: 0.5 # Accept partially valid moves above fraction. default: 0.5 KPIECEkConfigDefault: type: geometric::KPIECE range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability. default: 0.05 border_fraction: 0.9 # Fraction of time focused on boarder default: 0.9 (0.0,1.] failed_expansion_score_factor: 0.5 # When extending motion fails, scale score by factor. default: 0.5 min_valid_path_fraction: 0.5 # Accept partially valid moves above fraction. default: 0.5 RRTkConfigDefault: type: geometric::RRT range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability? default: 0.05 RRTConnectkConfigDefault: type: geometric::RRTConnect range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() RRTstarkConfigDefault: type: geometric::RRTstar range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability? default: 0.05 delay_collision_checking: 1 # Stop collision checking as soon as C-free parent found. default 1 TRRTkConfigDefault: type: geometric::TRRT range: 0.0 # Max motion added to tree. ==> maxDistance_ default: 0.0, if 0.0, set on setup() goal_bias: 0.05 # When close to goal select goal, with this probability? default: 0.05 max_states_failed: 10 # when to start increasing temp. default: 10 temp_change_factor: 2.0 # how much to increase or decrease temp. default: 2.0 min_temperature: 10e-10 # lower limit of temp change. default: 10e-10 init_temperature: 10e-6 # initial temperature. default: 10e-6 frountier_threshold: 0.0 # dist new state to nearest neighbor to disqualify as frontier. default: 0.0 set in setup() frountierNodeRatio: 0.1 # 1/10, or 1 nonfrontier for every 10 frontier. default: 0.1 k_constant: 0.0 # value used to normalize expresssion. default: 0.0 set in setup() PRMkConfigDefault: type: geometric::PRM max_nearest_neighbors: 10 # use k nearest neighbors. default: 10 PRMstarkConfigDefault: type: geometric::PRMstar xm_arm: planner_configs: - SBLkConfigDefault - ESTkConfigDefault - LBKPIECEkConfigDefault - BKPIECEkConfigDefault - KPIECEkConfigDefault - RRTkConfigDefault - RRTConnectkConfigDefault - RRTstarkConfigDefault - TRRTkConfigDefault - PRMkConfigDefault - PRMstarkConfigDefault projection_evaluator: joints(joint_lift,joint_waist) longest_valid_segment_fraction: 0.05 xm_gripper: planner_configs: - SBLkConfigDefault - ESTkConfigDefault - LBKPIECEkConfigDefault - BKPIECEkConfigDefault - KPIECEkConfigDefault - RRTkConfigDefault - RRTConnectkConfigDefault - RRTstarkConfigDefault - TRRTkConfigDefault - PRMkConfigDefault - PRMstarkConfigDefault projection_evaluator: joints(joint_finger_left,joint_finger_right) longest_valid_segment_fraction: 0.05 xm_arm_moveit_config/config/sensors_rgbd.yaml 这个文件用来配置MoveIt!的传感器插件，它可以使MoveIt!订阅点云数据来生成机械臂避障用的OctoMap。注意：这个配置文件不是用MoveIt! Setup Assistant自动生成的，你需要自己添加。 sensors: - sensor_plugin: occupancy_map_monitor/PointCloudOctomapUpdater point_cloud_topic: /head_kinect/depth/points max_range: 10 padding_offset: 0.01 padding_scale: 1.0 point_subsample: 1 filtered_cloud_topic: output_cloud xm_arm_moveit_config/config/xmbot.srdf 这是MoveIt!的主配置文件。这里面记录了我们使用MoveIt! Setup Assistant配置时的参数，里面包含了组群、位姿、末端执行器、虚拟关节，以及碰撞免测矩阵的定义。 下面，我们打开launch文件夹，你会发现里面有很多launch和xml文件。这时候不要慌，因为MoveIt!的模块化设计思想，它将不同的功能进行拆分并放到不同的文件中，所以文件看起来很多，但每一个都不是很长。这里，我只介绍其中几个重要的文件。 xm_arm_moveit_config/launch/demo.launch 这个launch文件是运行MoveIt!的根节点，它里面还包含了其他的launch文件。包括最为重要的move_group.launch。 [/move_group/fake_controller_joint_states] xm_arm_moveit_config/launch/move_group.launch 这个launch文件里面设置了很多运动规划时的参数。 xm_arm_moveit_config/launch/planning_context.launch 这里面使用了机械臂的URDF和SRDF文件，以及运动学解算库。不建议修改。 xm_arm_moveit_config/launch/xmbot_moveit_controller_manager.launch.xml 这个文件用来指定Controller配置文件的位置。注意：这个文件是MoveIt! Setup Assistant自动生成的，但我记得里面什么也没写。你需要下面例子中的那样进行配置。 xm_arm_moveit_config/launch/xmbot_moveit_sensor_manager.launch.xml 这个文件用来指定Sensor配置文件的位置。同上，你也需要自己编辑这个文件。 接下来，让我们运行两个例子来测试一下MoveIt!。 首先，我们测试一下MoveIt!的Motion Planning。请在终端中输入下列命令： $> roslaunch xm_arm_bringup xm_arm_bringup_moveit_and_gazebo.launch 在Rviz中，你可以使用末端执行器上的交互式Marker来移动机械臂到目标位置。接着，你可以在Planning Library的下拉式菜单中选择OMPL库中的某个特定规划算法。然后，点击Plan按钮，Rviz窗口中就会出现一条从初始位置到目标位置的运动轨迹并循环不断地播放。最后，点击Execute按钮，MoveIt!会将上一步规划出来的机械臂关节轨迹通过FollowJointTrajectoryAction接口发送给Gazebo中对应类型的Controller，使得Gazebo中的机械臂可以移动到目标位置，以下是测试的截图。注意：不同的规划算法所用的时间是不一样的。请尝试每一种算法，并记住最优算法的名字，这是为了之后方便在代码中对其进行调用做准备。 第二个例子，我们来测试一下带有Avoid Collision的Motion Planning。同样的，请在终端中输入下列命令： $> roslaunch xm_arm_bringup xm_arm_bringup_moveit_and_gazebo.launch 因为我在Gazebo中给机器人的头部添加了深度传感器的插件，所以当你把桌子放到机器人前方的时候，MoveIt!可以立马从点云Topic中获取物体的信息，并在Rviz中生成可视化的OctoMap。在下一次做运动规划的时候，MoveIt!会将由正方体组成的OctoMap看成障碍物并考虑在内。图中，机械臂的初始位置为伸直形态，我将其从桌子的下方移动到了桌子的正上方，规划的效果如下图所示。 当然，在使用MoveIt!对机械臂进行运动规划的时候并不是每一次都能成功，有些时候会出现超时报错的情况。遇到这种问题的时候，你可以尝试尝试其他OMPL算法，因为不同的OMPL算法可能对不同的情况有各自的优化。 最后，由于时间的缘故，我没能将MoveIt!的C++和Python的使用代码给整理出来，这对于我来说非常遗憾。不过，我相信随着MoveIt!学习教程的越来越丰富，有关如何用代码来做MoveIt!的运动规划会更加容易。 (3)、任务决策层 任务决策层处于整个架构图最顶端，是控制整个机械臂的大脑所在。首先，我要阐明的一点是：这一部分在我那一届机械臂软件代码中并没有实现，这是我后来总结机械臂开发经验的时候重新设计的。 至于我为什么要选择重新设计新的任务决策层，原因其实很明显，就是我们之前的那个存在着很多的不足的地方。我们之前的那个任务决策层架构比较松散，特别是机械臂的Action接口，我们定义了好几种，但是其中有几种的功能比较相近，显得比较冗余。而且状态机可以直接发送Action的Goal到机械臂模块中，换句话说就是没有经过封装的数据是一直暴露在整个任务决策的各个时间段，这会影响数据通信的稳定性，而且这样的代码也是不容易维护和重构的。 当然，除了上面存在的历史问题，还有一个影响我做出改进的因素就是：中科大蓝鹰队可佳服务机器人早期的抓取视频。视频中，可佳机器人的机械臂可以非常精准地操作微波炉，并抓取桌子上三种不同的容器。其中最难的是那个盛有牛奶的碗，整个碗只有一个地方向外伸出了一个手柄，能让机械臂末端手爪精准地抓住碗并且在移动其的过程中不让碗中的牛奶洒出来，这是非常厉害的。当时看完视频之后，我就被深深地震撼了，原来机械臂的自主抓取可以做到这样的程度！后来，西工大一小学生跟我们讲： 这个视频里最厉害的还不是机械臂的抓取，而是可佳机器人的任务决策部分。可佳可以通过对人语义的理解来自动生成相应的任务序列，而且这个任务序列是能被实时的修改和更新的。 因此，我决定对之前的机械臂任务决策模块进行封装，把所有与机械臂相关的软件细节都隐藏起来，最后暴露给外面的只有数据和任务接口。这样可以大大降低模块与模块之间的耦合性，并减少了不必要的进程通信开销，提高了程序运行时的效率。下面，我简要地讲解一下这个部分的原理。 任务决策层的核心简单来说是在其内部定义了一个小型的状态机，它可以根据不同的任务类型、物体位置以及物体的类型来选择不同的数据发给下面的运动规划层。这里我举一个具体的例子来说明其工作的整个流程：首先，机器人决策模块给机械臂的任务决策层发送了一个抓取的状态，任务决策层接收到之后就会在自己事先存储好的状态表中进行查找，如果匹配抓取状态成功，就把表中的状态链取出并放到状态队列中去。每次状态控制器会根据当前状态队列中的子动作来分析其所需要的数据。比如说，抓取状态可以拆分成很多子动作：初始、准备、抓取、手爪张开、手爪夹紧、手握物体等。此时，如果队列中第一个动作是初始，那控制器便会从预先设定好的机械臂位置池中取出相应的位置，并从MoveIt!参数表中取出其所需要的数据，最后通过MoveIt!接口把初始动作发送给运动规划层进行规范和执行。当机械臂完成这个动作后，任务决策层会比较机械臂实际运动的位置和预想位置之间的差值，如果误差小于某个值，其便会返回执行成果给控制器，控制器则会继续地执行下一个状态，直到整个状态队列中的动作都被执行完。如果误差过大，则报错退出，以防止机械臂出现任何不可控的意外情况。 最后，鉴于这一部分只停留在我的设想阶段，目前只供参考。至于最终能不能实现出来，还有待日后的验证。 三、学习流程 1、基础 （1）、开发规范 首先，我承认我对规范有一种近似疯狂的恪守。很多人都觉得学习开发规范对项目开发没有意义，简直就是在浪费时间。可是我一直坚信着：只有好的开发规范，才能产生成功的项目。我把学习开发规范作为基础中的基础，是因为我曾经在项目开发的过程中吃过这样的亏。因此，我希望每个开发者都能在为项目开始贡献之前耐下心来好好学习本团队的开发规范，并严格地执行规范中的内容。这里，我推荐Google开发规范和ROS开发规范。当然，如果你感兴趣的话，你可以看一下我曾经自己整理编写的晓萌团队开发规范。 （2）、版本管理 我认为掌握版本管理可以说是软件开发的必备技能之一，也是提高代码开发效率的绝对利器，希望大家好好地学习一下。版本管理主要涉及Git和GitHub的使用，这方面的学习资料很多，上网搜一下，花一段时间就能入门。 （3）、文档写作 这方面也有很多的开发者不是很重视。但个人认为如果你想成为真正的强者，只会编代码是远远不够的，你还需要优秀的文档写作能力。比如说你在开发的过程中遇到了一些问题，并成功地解决了。这个时候，你应该及时地将遇到的问题和解决办法以项目日志的形式记录下来，这样伴随着项目开发进度的不断向前，日志的内容也会越来越多。我敢保证，若干年之后，你一定会拥有别人绝对没有的宝贵财富！当然，除了开发日志外，你也要学会如何使用Markdown来编写项目文档。Markdown是你与开源世界交流的最重要的工具，一定要学会，况且它也并不是很难学。 （4）、编程能力 这个我就不用讲太多了，我相信如何学习编程，大家可能知道的比我还多。我这里主要想强调一下，一定要重点理解、学习C++。毕竟编译型语言要比解释性语言Python在执行效率上要高，而且对于机械臂开发来说，MoveIt!中的C++ API也要比Python的要多。 （5）、ROS基础 关于如何学习ROS，我推荐跟我曾经同在西工大舞蹈机器人基地的盛盛在易科上发表过的一篇文章：如何学习ROS——盛盛经验谈。这里，我想补充一下，对于机械臂开发来说，除了盛盛在文章里讲到的那些内容之外，各位还要重点理解以下几个部分： Action ROS Control Joint State Publisher Robot State Publisher Joint Trajectory Controller URDF Xacro Launch XML Gazebo Connect to ROS 2、进阶 等你学习完以上的内容之后，我相信你已经打下了坚实的基础。这个时候，你可以开始入门MoveIt!了。学习MoveIt!的时候，一定要多实践，遇到问题多在ROS Answers上搜一搜，我相信大部分问题的解决办法你都能找到。有关机械臂的URDF模型，我推荐刚开始入门的时候先从简单的机械臂模型入手，不要一上来就整个PR2的，一是机械臂关节比较多，二是我估计你的电脑不一定能带的动。 还有就是要熟练地掌握Gazebo仿真软件，因为我觉得并不是每个人都有机械臂，机械臂的成本确实比较高，这个时候如果你学会了如何在仿真环境下搭建机械臂模型并将其与MoveIt!连接在一起，你就能在一定程度上节约时间、资金成本。当然，仿真是永远无法替代实物的，这个我之前在开发机械臂的时候就深刻地体会过，不过，把Gazebo当做算法的前期验证平台还是非常好的。 多看看别人的MoveIt!配置是什么样的，然后你自己再重新地配置几遍，主要是熟悉其中的一些概念。最后，在Rviz里试着拖动机械臂到新的位置，点击Plan按钮看看MoveIt!是怎么通过IK来输出一条平滑的轨迹的。当然，如果你配置好了深度传感器接口的话，可以试一试MoveIt!是如何在有障碍物的情况下进行运动规划的。 总之，想要开发好机械臂，MoveIt!+Gazebo是必不可少的。 3、高级 至此，如果你能按照我说的完成前两步的话，你应该已经会用MoveIt!，并能用其做简单的运动规划了。当然，如果你想成为机械臂开发大神的话，你还需要重点学习MoveIt!的代码API。MoveIt!的API不少，你需要多尝试，找到最适合你们机械臂使用的API（推荐C++的API）。 在MoveIt!中，碰撞检测使用的是FCL库。你需要了解和学习FCL的API，并将其融入到机械臂的运动规划中去。 MoveIt!默认使用OMPL库来做运动规划，你可以去OMPL的官网仔细地学习一下它的使用方法。如果你有时间的话，也可以研究一下其他几种规划器的效果如何，比如STOMP、SBPL、CHOMP等。 如果你认为你已经对MoveIt!的使用了如指掌，你可以尝试挑战一下难度——根据你们自己机械的实际情况，手写IK解算插件并将其集成到OMPL中去。 完成以上之后，你如果发现自己还想在机械臂领域有更多的提升空间，那工程开发显然已经不能满足你的需求了，你需要阅读机械臂方面的论文以及专业书籍。这里我推荐《Robotics - Modelling, Planning and Control》这本书，里面深入地讲解了机器人的建模、轨迹规划以及运动控制等相关内容。 4、资源 以下是我认为学习机械臂比较好的资源，推荐给大家。 (1)、网站 MoveIt!官方文档 (2)、书籍 《Effective_Robotics_Programming_with_ROS_Third_Edition》 《Learning_ROS_for_Robotics_Programming_Second_Edition》 《Mastering_ROS_for_Robotics_Programming》 《Programming_Robots_with_ROS》 《Robot_Operating_System(ROS)_The_Complete_Reference》 《ROS_By_Example_2_Indigo》 《ROS_Robotics_By_Example》 (3)、博客 西工大一小学生： ros_control攻略 古月居： ROS探索总结（二十五）——MoveIt!基础 ROS探索总结（二十六）——MoveIt!编程 ROS探索总结（三十一）——ros_control redefine： 运动规划 (Motion Planning): MoveIt! 与 OMPL 基于OMPL的采样运动规划算法(Sampling-based Motion Planning) yaked： 在qt下编写基于KUKA youbot API的程序 用ROS控制KUKA youbot的5自由度机械臂和夹子 给KUKA youbot机械臂添加dynamic reconfig Actionlib与KUKA youbot机械臂 利用rqt_plot与matlab分析KUKA youbot的joint_states信息 KUKA youbot机械臂与Moveit工具包（1） KUKA youbot机械臂与Moveit工具包（2） KUKA youbot机械臂与Moveit工具包（3） Gazebo与ros_control（1）：让模型动起来 Gazebo与ros_control（2）：七自由度机械臂和两轮差速运动小车 Gazebo与ros_control（3）：Moveit输出规划轨迹到Gazebo Gazebo与ros_control（4）：举一反三，实战youBot 邱博士： 使用MoveIt进行运动规划 实例介绍机械臂运动规划及前沿研究方向 邱博士知乎问题回答 创客智造： MoveIt!入门教程系列 四、总结 我在大二的时候了加入西工大舞蹈机器人基地家政组，负责机械臂的软件开发工作。那个时候ROS的版本还是Indigo，MoveIt!用的人还不是很多，RoboCup@Home比赛队伍中用机械臂的还很少。如今接近两年的时间过去了，当我再次打开MoveIt!官网的时候，教程的数量和质量已经不可同日而语了。我相信现在的机器人爱好者或研究者们要比我当初那会儿更容易地学习并掌握机械臂的开发，并能将其应用到解决当今人们所遇到的问题中去。我们正处在人工智能的伟大时代，而机器人作为人工智能技术最为重要的技术载体，需要我们为此付出努力并勇于探索前方未知的道路。最后，我希望这篇文章可以让更多的开发者迈入机械臂开发的大门，并为机械臂的研究发展贡献你们自己的一份力量！ Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 15:01:30 "},"docs/Tutorial/Advanced/Multi-Robot/":{"url":"docs/Tutorial/Advanced/Multi-Robot/","title":"Multi Robot","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-08 23:01:00 "},"docs/OpenRE/":{"url":"docs/OpenRE/","title":"OpenRE","keywords":"","body":"HandsFree OpenRE OpenRE全称Open Source Robot Embedded Library ， 是一个专门为机器人写的、基于STM32系列微处理器的嵌入式开源库。经过不断优化，开源库变得鲁棒和通用，从而独立于平台成为一个专门为机器人而生的一个嵌入式库。 主要目的是搭建一个专门为机器人服务的嵌入式跨平台软件框架，涵盖底层设备驱动，算法库，通信与操作系统组件等，主要涵盖以下内容： 封装了许多传感器、存储器、输入输出设备的驱动包，并且采用硬件和驱动包隔离的方式，开发者可以轻易的跨平台移植，比如各种伺服设备、数模舵机、直流三相电机、各种传感器、加速计，陀螺仪、磁力计、超声、 GPS、一些交类互 LCD、触摸屏、 flash、 EEPROM、 SD 卡驱动等。 具有已经移植好的操作系统层功能，实时操作系统（ RTOS），图形库（GUI），网络协议（LWIP）， USB 协议，使用者可以根据自己的需求，选择合适的模板进行开发，省去了移植过程的繁琐操作。 具有很多机器人有关的算法库、 PID 控制包、机器人运动坐标变换包、卡尔曼滤波包、矩阵运算包、四元数等。 支持Linux环境下的makefile + QTCreator + armgcc来进行开发 在你正式进行开发之前，你需要准备一些基础知识，会使用linux系统(支持ubuntu 14.04 + ROS indogo ， ubuntu16.04 + ROS kinetic)，会用git github管理自己的代码，会使用qtcretor，详情请看2.-Robotics-Learning OpenRE简述 获取OpenRE源码： OpenRE源码 OpenRE库使用makefile + QTCreator + armgcc来进行开发，相信熟悉makefile的都知道它有多方便，至于windows系统的开发者，也是可以配置windows下的makefile + QTCreator + armgcc的环境来开发的，这里也强烈建议开发者学习使用makefile，在构建大规模程序框架的时候显得特别给力。对于只熟悉集成开发环境的开发者，或许认为keil更加的方便，但其实是“会者不难，难者不会”。若是实在不想学习强大的make，你也只需学习OpenRE的操作方法来进行开发。不过HANDSFREE的宗旨第一要义是学习和科研，追求永无止境，不断创新，所以OpenRE就不提供keil的工程文件了。 获取makefile的学习资料：makefile学习资料 OpenRE库还移植了PX4的bootloader，增加了硬件抽象层以适用于不同的电路板，增加了Eigen和Matrix矩阵运算库，对框架和一些包都进行了优化等等。 在你正式进行开发之前，你需要准备一些基础知识，会使用linux系统(支持ubuntu 14.04 + ROSindogo ， ubuntu16.04 + ROSkinetic)，会用git管理自己的代码（同时注册一个github账号），会使用qtcretor。 OpenRE环境配置 OpenRE Toolchain 关于工具链的配置有两种方式，可以直接用apt-get 安装，如果网速太慢也可以在百度云下载deb包安装。 Method1: sudo add-apt-repository ppa:terry.guo/gcc-arm-embedded sudo apt-get update sudo apt-get install openocd gcc-arm-none-eabi sudo usermod -a -G dialout $USER sudo apt-get install lib32ncurses5 libtool libusb-1.0 libftdi-dev python python-serial python-empy libpython2.7:i386 sudo apt-get remove modemmanager Method2:(recommended) get toolchain it in Development_Toolchain put these softwares in OpenRE/5_Development_Toolchain open a terminal and run: cd 5_Development_Toolchain tar -jxvf gcc-arm-none-eabi-5_4-2016q2.tar.bz2 tar -jxvf openocd.tar.bz2 tar -jxvf stlink.tar.bz2 cd openocd/ ./configure make clean make cd ../stlink/ make clean make cd ../ sudo usermod -a -G dialout $USER sudo apt-get install lib32ncurses5 libtool libusb-1.0 libftdi-dev python python-serial python-empy libpython2.7:i386 sudo apt-get remove modemmanager 代码编译与烧写 用jlink烧写时，由于不同的电路板外部晶振频率可能不一样，所以把A板的固件烧到B板就可能导致死机和锁死，然后下一次烧写的时候就烧不进了，当出现这种情况的时候，方法就是按下板子的复位键(按住不动)，运行烧写指令，一两秒后，松开复位键，就能烧写进去了。 为了确保你不会烧写错误，你先确保每个工程的makefile文件和你的板子是匹配的。这里先介绍每个工程所独有的makefile，下一篇会详细介绍整个库的makefile。 白色字体是变量，黄色字体是变量值，注释部分是变量的可选值。接下来介绍每一个变量的含义。 BOARD_TYPE：电路板型号，可选值是HANDSFREE生产的几款电路板（目前是3款，control_unit_mini、control_unit_v1和control_unit_v2）。 ROBOT_MODEL：是当前使用的机器人的型号，可选值是HANDSFREE发布的几款机器人，（目前是三款，null、jilong、jilong_omni3和stone，null代表无机器人对象，在跑OpenRE简单测试程序的时候使用）。 ROBOT_SIMULATION_MODE：仿真模式使能，如果enable，将不需要实体机器人，我们在电路板内部虚拟电机的存在。一般情况下都选择disable。 BOOTLOADER_MODE：BOOTLOADER模式可以让用户直接从串口下载程序，如果disable就需要用jlink下载。目前默认disable。 PAKG：代表本程序所需要使用到的功能包，在简单测试代码里，只用到了common包。在机器人实现代码里，用到了就相对较多了。如果不是自己开发程序，该部分内容一般不做修改。 OS_MODULE：操作系统的模式，目前支持UCOSII、UCOSIII。如果裸跑单片机程序，就空着不填。 THIRDPARTY_MODULE：第三方库的选择，比如矩阵库之类的，如果使用就在这里填上对应的第三方库名称。 在正式烧写前，请确保你之前的makefile都配置对了，主要是ROBOT_MODEL，BOARD_TYPE，BOOTLOADER_MODE这三个变量。 直接使用jlink的SWD模式进行烧写 先编译一个简单的工程验证一下你的开发环境已经配置成功： 把makefile的BOARD_TYPE改成你板子的型号，如果你使用的第三方板子，则需要看懂makefile，看后面的配置是不是符合你的板子。 插上jlink同时用usb为板子供电。 打开一个简单工程的makefile文件所在的目录，该makefile为顶层makefile： cd OpenRE/0_Project/examples/handsfree_simple_app/linux 接着编译： make 最后烧录： make burn 烧写成功的现象是，板子上的led灯持续闪烁。 （注：如果是重复烧录同一份代码，从第二遍开始就可以省去make clean和make步骤，直接make burn。但是如果两次烧录之间，有.h头文件被修改，就要先make clean，再make，最终make burn。） Makefile选择不同的机器人与主控的方式 其实在上一节编译与下载章节就已经讲解过了，主要就是修改如下两个变量。 BOARD_TYPE ?= control_unit_v2 ROBOT_MODEL ?= stone 一个是选择电路板的型号，一个是选择机器人的型号。可选项在makefile里面都以注释的形式标示出来了。 （注：非嵌入式开发者只需看完前两章即可） Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-15 15:19:51 "},"docs/OpenRE/Getting-Started.html":{"url":"docs/OpenRE/Getting-Started.html","title":"Getting Started","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 14:19:59 "},"docs/OpenRE/Architecture.html":{"url":"docs/OpenRE/Architecture.html","title":"Architecture","keywords":"","body":"第四章 架构介绍 Makefile详解 每个工程都有一个自己的makefile文件（已经在上文讲解过），并且都include了顶层目录下的compiler_config.mk，而compiler_config.mk文件又包含了其它的.mk文件。 这里主要介绍以下几个重要的.mk文件，看懂这几个文件，自己DIY就完全不是问题。 compiler_config.mk: 这个文件除了去包含其它几个.mk之外，还定义了编译的规则，一句话来说，就是定义合适的规则，按照合适的编译流程，编译出.elf文件并且转化成可供烧录的.hex 和 .bin固件，懂makefile的应该是秒懂啦。 重要代码： ifeq \"$(strip $(BOOTLOADER_MODE))\" \"enable\" DDEFS += -DBOOTLOADER_ENABLE endif 解析BootLoader使能情况，同时定义全局宏表征使能失能。 ARMGCC = $(TOP_PATH)/5_Development_Toolchain/gcc-arm-none-eabi-5_4-2016q2/bin/arm-none-eabi-gcc ifeq ($(ARMGCC),$(wildcard $(ARMGCC))) CCPREFIX ?= $(TOP_PATH)/5_Development_Toolchain/gcc-arm-none-eabi-5_4-2016q2/bin/arm-none-eabi- else CCPREFIX ?= arm-none-eabi- endif 在指定目录下寻找编译器，如果没有找到，就启用电脑里安装的编译器。主要是方便内部开发人员的，对大家来说可能没啥用。 OPT += -O0 ARMGCC交叉编译的优化等级，可选参数为0、1、2、s建议在debug时候启用0级优化，这样能解决程序很多的潜在问题，编译成功之后启用s级优化，缩小编译后产生的文件大小。 ifeq \"$(strip $(CPU_TYPE))\" \"STM32F1\" FPU_STATE == disable endif ifeq \"$(strip $(CPU_TYPE))\" \"STM32F4\" FPU_STATE == enable endif ifeq \"$(strip $(FPU_STATE))\" \"enable\" OPT += -mfloat-abi=hard OPT += -mfpu=fpv4-sp-d16 endif 根据芯片型号，决定是否启用FPU（浮点运算单元）。再根据是否使能FPU选择是否使用硬件浮点数等其他对应的编译选项。 system_para.mk: 这个文件主要是电路板硬件资源分配的参数设置文件。目前主要就是解决通信端口的资源分配。 ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_mini\" DEBUG_PRINTF_INTERFACE ?= usart_interface_4 PC_INTERFACE ?= usart_interface_1 RADIO_INTERFACE ?= usart_interface_4 endif 开头的三段代码是一个功能，就是根据当前电路板的型号（已经在顶层的makefile确定），设置具体的硬件资源分配，上面这段代码的含义是，用串口4作为debug的通信口，串口1作为pc端和主控板的通信口，串口4同时还作为主控与遥控器的通信口。 在这之后的内容，就是根据之前确定的参数，设置全局宏定义，传入到程序中去。 board.mk： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_mini\" DDEFS += -DCONTROL_UNIT_MINI -DSTM32F10X DDEFS += -DHSE_VALUE=8000000 -DUSE_STDPERIPH_DRIVER MCU ?= cortex-m3 CPU_TYPE ?= STM32F1 BOARD_ABSTRACT += $(TOP_PATH)/1_Processor/BoardAbstract/control_unit_mini.cpp endif package.mk CXX_SRC+=$(foreachn,$(PAKG),$(wildcard$(PACKAGE_PATH)/$(n)/* .cpp)) 就是对makefile的PAKG变量进行解析，只要是依赖的包，就包含其源文件和路径。 基于OpenRE和HandsFree主控编写机器人程序 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-03-31 15:56:33 "},"docs/OpenRE/Develop.html":{"url":"docs/OpenRE/Develop.html","title":"Develop","keywords":"","body":"第五章 OpenRE实战 代码框架介绍 OpenRE框架图 OpenRE的代码由底层到上层主要分为底层接口函数库、常用外设驱动库、OS库、机器人对象的抽象库、第三方库的移植等。下面对每每类函数库做简单介绍。 底层接口函数库在官方固件库的基础上，将对GPIO、定时器、编码器、USART、CAN、IIC、SPI、ADC和PWM等底层资源的操作进一步进行封装。 常用外设驱动库根据官方固件库，对常用的外设提供驱动，例如电机控制、舵机控制、LCD屏幕驱动、GPS模块解码、航模遥控器的解码和IMU的数据处理等。 OS库 开发的应用程序包含裸跑程序版本和有操作系统版本，该库包含ucos操作系统的相关文件。 机器人对象的抽象库 对移动底盘模型的抽象，包括差分底盘、4轮麦轮底盘和3轮全向轮底盘等。 第三方库的移植移植的第三方库，包括Dobot机械臂库，Eigen3和Matrix矩阵库。 第三方主控的移植 OpenRE是一个开源机器人嵌入式系统。为了让更多的机器人爱好者能够使用到它，我们在这里推出将OpenRE移植到第三方主控（非HANDSFREE出品主控）的教程。 很多机器人爱好者在接触到OpenRE的时候会有这样的疑问，我有自己的机器人，我有自己的嵌入式主控，可是我想用OpenRE进行开发，我该怎么办呢？关于这个问题，首先，我们要将OpenRE移植到你自己的主控上去，当一切调试顺利之后，参照教程 4.3基于OpenRE和HandsFree主控编写机器人程序 ，即可让OpenRE运行在自己的机器人上。 接下来，我们就开始第三方主控移植之旅。 在代码框架介绍一节里，大家应该已经掌握到，OpenRE代码按照文件夹的编排可以分为四部分：工程文件、主控描述文件、功能包文件、操作系统文件和第三方库文件。 操作系统文件是服务于Ucos操作系统的。 第三方库文件是我们在工程中实现某些特定功能时调用的别人已经写好的库. 我们可以暂时将这两份文件放在一边。剩下的三个文件中， 主控描述文件是最底层的，它包含了所有与电路板最底层操作相关的函数实现，这些底层驱动函数将大量地在工程文件和功能包文件中被调用。 换句话说，当我们想将OpenRE移植到自己的电路板上时，我们只要完成好主控描述文件的编写，让其对外暴露的API与原先的一致，就不需要对工程文件夹和功能包文件夹做任何修改，OpenRE也就成功移植到第三方主控了。 接下来我们详细剖析一下主控描述文件（1_Processor），主要包含三部分： BoardAbstract： 包含一个board_abstract父类和board子类。board_abstract类是顶层的板级抽象类，它留出了所有对电路板操作的API接口，但是考虑到不同的板子硬件设计不一样，所以在某些可能出现不同的地方，我们使用了虚函数，再用每块板子对应的board子类去继承board_abstract类并将虚函数具体实现。 每一块板子都将有一个control_unit_xxx.cpp（也就是board子类具体实现的地方）与之对应，这些cpp文件种包含了led初始化、蜂鸣器初始化、电机接口初始化、电机使能失能、ADC初始化等。大家可以发现，这些操作都需要与具体的电路板的硬件设计所对应，比如LED具体对应哪个IO口，这是因板而异的，所以我们需要在子类去对应着实现。 值得注意的是不同的control_unit_xxx.cpp都使用的同一个board.h头文件，这就保证了对外API接口的一致，至于在某工程中到底是哪个control_unit_xxx.cpp与board.h关联起来，取决于board.mk的编写，感兴趣的可以往上翻到 4.2Makefile 详解再看一下。 Interupt： 这部分就是中断处理函数的描述，应该不需要做修改。 6个串口中断函数（F1的话是5个）不断的将串口收到的数据压入各自的队列； 一个主中断函数，不断的在计时，用于while(1)中的分频操作； 一个异常中断，单片机发生异常后会在这里利用蜂鸣器报警。 STM32F4/STM32F1： 这里面使我们编写好的BSPLIB，里面把单片机各种底层功能都打包实现了，可以直接调用。 由于确定型号的单片机的IO的资源都是固定的，比如F1的串口1在没有重映射的情况下一直都是PA9、PA10，所以该部分文件也不需要改动。 综上所述，移植OpenRE到第三方主控的流程如下： 新建一个control_unit_xxx.cpp（xxx是你的电路板的名称）。 仿照着现有的control_unit_v2.cpp将所有函数按照你的电路板的特性实现好。函数名不要变，要和board.h能对应起来。 修改board.mk，添加你的电路板的信息如下： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_xxx\" DDEFS += -DCONTROL_UNIT_XXX -DSTM32F10X DDEFS += -DHSE_VALUE=8000000 -DUSE_STDPERIPH_DRIVER MCU ?= cortex-m3 CPU_TYPE ?= STM32F1 BOARD_ABSTRACT += $(TOP_PATH)/1_Processor/BoardAbstract/control_unit_xxx.cpp endif 其中的，MCU、CPU_TYPE和“-DSTM32F10X”需要根据你使用的芯片情况改动。 在system_para.mk文件里添加你的电路板的硬件资源分配信息： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_xxx\" DEBUG_PRINTF_INTERFACE ?= usart_interface_4 PC_INTERFACE ?= usart_interface_1 RADIO_INTERFACE ?= usart_interface_4 endif 三个参数分别是，debug通信口、pc端和主控通信口、遥控器通信口。你只需要根据自己电路板的硬件资源分配来填写就好。 在工程文件夹的Makefile里面修改第一行： BOARD_TYPE ?= control_unit_xxx 重要功能包讲解 在本小结，我们将单独拎出几个比较重要的软件功能包做一个比较细致的讲解，方便大家了解并学习一些重要功能的实现方法。 common： 该功能包包含了两部分文件，一个是调试接口的printf重映射，用于将printf信息打印到串口调试助手上。还有一个是接收消息的队列实现queue.cpp。我们为每一个串口都创建了一个队列用于接收消息，发送过来的数据会在串口中断处理函数里被压入队列。在程序的其他进程中，读取队列中的数据进行处理。 hf_link: 由于hf_link较为繁琐，我们放在第六章系统讲解。 motor： 该功能包包含电机控制代码motor_control和motor_top。 motor_control中最重要的是pidOrdinaryCall函数和pidSeriesCall函数。 同时我们还创建了motor_control类，实现了通用的PID控制函数，也留出了与具体电路板设计有关的电机初始化，使能等虚拟函数接口，在其子类DC_motor类中具体实现。 pidOrdinaryCall：该函数是单级PID函数，输入参数按顺序包括期望的总里程、实际测量总里程、单位时间内期望里程和单位时间内实际测量里程。函数的输出则是提供给电机的PWM值。 PidSeriesCall：串级PID，感兴趣的同学可以自己去看源码扒一扒，目前我们使用的是单级PID，效果已经可以达到控制的要求了。 motor_top中包含了电机的初始化函数、控制回调函数和电机测试函数。同时我们定义了两个类，一个是直流电机类DC_motor，它继承了motor_control类，将motor_control类中的虚函数具体实现了一下。DC_motor可以看作是对某个具体电机所建立的对象，motor_top类则是将机器人所使用的电机建立一个群组对象，实现对所有电机的统一管理。 motorTopInit：电机初始化函数，输入包括初始化电机的个数、PID控制周期、电机参数和仿真模式使能。 motorTopCall：该函数将在While(1)中以固定频率调用，实现对机器人底盘所有电机的控制。 motorTest：该函数在通常只在电机调试的时候使用，换句话说是内部人员开发的时候测试电机用的。使用方法是将其和motorTopCall放在一起，并屏蔽掉main.c内部的robot_control_p->call();函数。 robot_control： 该功能包包含四部分，分别是机器人的手臂、底盘、云台（头）和机器人的总体控制。 Chassis（底盘）部分，构建了一个底盘类，主要实现了底盘的参数设置，底盘运动的相关数据解算。 setParameters：设置底盘的相关参数，包括底盘的型号、尺寸大小等。这里有个很关键的思想，我们定义了一个父类的TF_robot类，实现机器人速度和电机速度的转换，针对不同的地盘结构，有不同的子类去继承该父类，将父类的速度转换函数实例化。所以这边我们构造了一个父类对象，再根据机器人的底盘型号指向不同的子类，实现代码的封装。 Init：初始化底盘，其实就是调用了上面的函数。 updataGlobalSpeed：将机器人全局速度解算成各个轮子的速度。 updataRobotSpeed：将机器人坐标系速度解算成各个轮子的速度。 call：底盘控制回调函数，根据编码器数据解算里程。 robot_control（机器人总体控制）部分，我们实现了一个机器人控制类，面向的是整个机器人，在统筹手臂、云台（头）和底盘的控制的同时，还负责了hf_link的响应。其中最重要的函数是call和hfLinkNodeEvent。 call：机器人控制回调函数，内部运行了hf_link响应函数和机器人三个部分（手臂、头和底盘）的控制回调函数。该函数在while(1)中以固定频率调用，实现对机器人的控制。 hfLinkNodeEvent：hf_link响应函数。当hf_link将机器人某些数据或参数更新之后，需要做出一些响应。比如hf_link更新了机器人的全局坐标速度之后, receive_package_renew[SET_GLOBAL_SPEED]标志位就会置1，一旦检测到该位的变化，则调用chassis.updataGlobalSpeed();将全局速度解算成每个电机的速度，实现机器人的移动。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 15:19:20 "},"docs/OpenRE/HFLink.html":{"url":"docs/OpenRE/HFLink.html","title":"HFLink","keywords":"","body":"第六章 OpenRE通信详解 HFLink详解 该功能包包含了两个类：StateMachine类和HFLink类。 StateMachine类中定义了一个HFMessage结构体，该结构体描述了一个数据包的信息：包括发送者id、接受者id、有用数据长度和数据内容存放数组（容量最大为120字节）。 StateMachine类最重要的是状态机接收函数StateMachine::receiveStates和StateMachine::sendMessage函数。 StateMachine::receiveStates(const unsigned char rx_data)： 该函数会在程序中被循环调用，每次调用，都会将从串口接收消息队列中取出的最新的一个字节的数据传输到函数内部。每次只要传入的数据符合当前状态的要求，状态变量就会自动改变为下一状态，当程序顺利遍历完一遍所有状态之后，预示着收到一个完整可用的数据包，这时候该函数返回1（否则返回0），提示hf_link.cpp中的数据分析函数byteAnalysisCall可以开始进行数据分析。 StateMachine::sendMessage(constHFMessage* txmessage)： 与状态机接收函数相反，该函数是将我们需要上传的数据进行打包发送，确保能够通过上位机的状态机接收函数。该函数的输入参数就是指向待发送数据包的HFMessage类型的指针。 HFLink类继承了StateMachine类，为了使用StateMachine类中的状态机接收函数和数据包发送函数。 同时，在HFLink类中，我们定义了Command枚举变量，里面都是指令类型，在解析数据包的时候，需要根据不同的指令类型做不同处理。 除此之外，因为PC端和主控端共用hflink代码，所以我们使用char型变量hf_link_node_model来区分上下位机（0 slave , 1 master）。 接下来我们来详解HFLink中的函数实现。在这里不贴代码大家可以打开文件hf_link.cpp对照查看。 HFLink::byteAnalysisCall(const unsigned char rx_byte)： 该函数会在while(1)中不断被调用，第一条if判断语句一旦判断正确，预示着状态机接收到一条完整的数据包。接着，会调用HFLink::packageAnalysis进行数据处理。 HFLink::packageAnalysis(void)： 第一次通信前需要上下位机握手，类似于一次通信尝试，告诉对方接下来要开始通信了。下位机调用该函数 sendStruct(SHAKING_HANDS , NULL , 0); 向上位机发送握手请求，上位机收到握手请求后会向下给出答应，下位机收到应答后将shaking_hands_state标志位置1。握手成功。 接下来开始正常通信。 首先，根据状态机中获得的数据包的第一位数据确定指令的类型： commandstate = (Command)rx_message.data[0]; 接着利用switch语句，针对不同的指令类型调用不同的数据处理函数。 数据处理函数主要是两个，setCommandAnalysis 和 readCommandAnalysis。 setCommandAnalysis： 赋值指令分析函数。将上位机发过来的用于设置下位机某些参数或者变量的数据，通过memcpy函数，赋值给下位机对应的变量或参数。 readCommandAnalysis： 信息请求指令分析函数。收到上位机的数据请求消息之后，将下位机的某些变量或者参数，用memcpy函数拆分为多个字节的数据，打包发送给上位机。 HFLink::sendStruct(const Command command_type , unsigned char* p , unsigned short intlen)： 消息发送函数。传入参数包括：指令类别、指向发送内容首地址的指针和发送数据的长度。函数内部主要是填充了HFMessage类型数据的相关信息。 如何自定义通信指令 首先，明确自定义通信指令的作用，涉及到的数据，并且根据通信指令的作用给自己的这条通信指令起个名字。 接着，在hf_link.h中，将该通信指令的名称添加到LAST_COMMAND_FLAG之前。 之后，在hf_link.cpp文件中找到HFLink::packageAnalysis(void)函数，在switch函数里面，仿照之前通信的格式添加新的通信指令解析内容。对于上下位机来讲，都是调用两个函数，setCommandAnalysis和readCommandAnalysis，这两个函数传入的参数都是三个，第一个指令类型，这个不需要自己改，因为是从更外面的函数传进来的，第二个是指向本条通信所涉及到的数据的指针，也就是相关数据的首地址，第三个是数据长度，用sizeof函数就好。如果本条指令不涉及到参数的传递（只是单纯的动作执行指令），就使用NULL指针，数据长度为0。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-03-31 15:57:17 "},"docs/Courses/":{"url":"docs/Courses/","title":"Courses","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-28 14:14:37 "},"docs/Courses/Robotics-Learning.html":{"url":"docs/Courses/Robotics-Learning.html","title":"Robotics Learning","keywords":"","body":"机器人入门 概述 机器人是一个复杂系统，对理论和工程知识的要求综合度是非常高的，如果你没有足够的激情，不断学习的心态，独立解决困难的决心，建议你还是不要入这个神坑。 即使你有上述的基本素质，机器人也不是想玩就能玩的，至少不是你有钱买个平台你就有能力玩起来的， 虽然我自己也很菜， 但是我还是得给新手指指方向。我觉得如果你能满足以下条件再开始你的HandsFree开发之旅会比较好一点。 编程功底要够好 编程就和学英语一样，需要你在平时的科研进程中不断学习和练习，没有最强只有更强，不懂计算机语言永远别想踏进IT世界，而然编程语言多如牛毛，不同领域的软件工程师有不同的选择，也很难划定界限。如果你以后要搞机器人系统，机器学习，计算机视觉 ，我建议要掌握好C++ 和 python ， 特别是如果你是走工程路线的话，那么C++一定要非常好，这也是学ROS HandsFree 必过的一关。具体可以参考C++学习规划。 对机器人的整体系统有一定的了解 虽然你可能只是一个 SLAM，计算机视觉，机器学习等局部问题的研究者，但是如果你要玩整机那就得对整体系统，从机械结构到机器人学，电路，嵌入式等有一些最基本的了解。这本书可以帮你入门，请确保你可以看懂： 自主移动机器人导论 （美）西格沃特（Siegwart,R.），（美）诺巴克什（Nourbakhsh,I.R.） 学习ROS ROS 可能是大部分人入门的工具，请你在有一定基本了解的前提下再买我们的平台，否则你可能会失望，除非你懂机器人且不用 ROS 来构建你的机器人系统。ROS学习请参考 ROS 学习规划 C++学习规划 最基本的是要能看懂 stephen prata 的《C++ Primer Plus》 ，另外《C++ 标准程序库》可供参考，相关资料可以参考HandsFree 百度云提供的编程学习资料 对C++语法和编程有一定基础之后，你也许已经写过很多小程序了，接下来你需要培养你看大工程代码的感觉，就和学英语一样，掌握语法和句子之后，看看英语文章或者小说会增加你的阅读能力，以下是个人建议 掌握几个知名的库，比如qt，opencv ， boost等 ， 可以参考 qt 学习教程 通过工程实战来提升运用能力，比如看一些常用的ROS的包或者仔细研读HandsFree的代码，也可以根据自己的研究方向去学习相关的开源工程，通过改开源的代码实现一些自定义的应用，久而久之，你就有能力独立的搭建大工程了。 在这个过程中，你对编程会有一些自己的体会，并慢慢的需要看一些编程思想，编程风格之类的书，并需要对C++有更深的理解，推荐学习google 和 ros 的编程风格 ，阅读《(More)Effective C++》、《(More)Exceptional C++》、《Effective STL》及《C++编程规范》提升对C++的理解，可以参考HandsFree百度云 编程学习资料 提供的相关资料。 在以上过程中，会发现那些优秀的工程比如ROS Qt 等就像精美的艺术品，娴熟的语法运用，优美统一的风格，严谨紧凑的逻辑，这除了说明他们对自己领域的知识看的非常透彻外，也说明他们驾驭编程已经上升到编程哲学境界了，虽然这辈子我们都难成为这种高手，但是有必要关注一下高手的世界。我们可以通过学习设计模式 和 泛型编程，来帮助我们理解如何构建大的软件工程。 ROS 学习规划 关于ROS的学习，现在网上已经有很多中文教程了 , 可以参考 易科机器人，RosClub，最重要的是要学会如何使用ros wiki。 HandsFree不是ROS基础教程，只适合有一定ROS基础的同学深入学习研究ROS，或者基于HandsFree研究机器人相关话题比如SLAM ， 机械臂控制，多机器人协同。如果你要开始使用或者购买HandsFree平台，请确保你已经满足以下条件。 请确保你看懂beginner level 的教程，如果你的经验还不够多，请多看几遍。 请确保你看过比较正式的书籍，随便一本你看懂了就行：比如你已经大概看懂 ros by example 1 indigo 前 8 章 另外我再推荐一个国外的 ROS 入门 ppt： http://u.cs.biu.ac.il/~yehoshr1/89-685/ 相关学习资料可以看HandsFree百度云 ，如果你以上条件你都 ok， 那么入手实物机器人就比较科学了，当然你要知道的远不止这些，很多细节的问题和工程经验是列不完的。 相关学习资源 https://hands-free.github.io/ http://blog.exbot.net/archives/2790 https://zhuanlan.zhihu.com/p/22763273 http://blog.exbot.net/archives/1129 http://www.guyuehome.com/ 需要的工程素质 学会使用google，翻墙，查资料 对机器人系统有一定认识，机械结构，电路，嵌入式，传感器等 学会用markdown来编辑文档，这是我们团队的通用文档格式之一 会用git，github 来管理代码，与人合作开发 软件开发人员最好熟悉使用linux，学会makefile cmake linux_shell xml 等常用的脚本或标签语言 参考学习方向 移动机器人基础 了解机器人的定义，各种不同形态的机器人：无人机，地面机器人，水下航行器 以及其子分类。 着重了解地面机器人中的轮式移动机器人，了解不同结构的移动机器人：差速，全向，平衡车，汽车形态的等等 了解移动机器人的历史 ， 组成和功能：云台，地盘，机械臂，升降杆等 移动机器人的各种伺服结构和驱动方法 移动机器人的各种传感器的作用，以及整个移动机器人系统是如何工作的，如何实现自主。 各个组别的学习可以参考HandsFree NWPU Club的分组学习计划 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-05-11 14:47:10 "},"docs/FAQ/":{"url":"docs/FAQ/","title":"FAQ","keywords":"","body":"Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-10-29 12:32:10 "},"docs/FAQ/when-usb-was-broken.html":{"url":"docs/FAQ/when-usb-was-broken.html","title":"when usb was broken","keywords":"","body":"串口USB插拔损坏解决方案 OpenRE的灵活性之一体现在对硬件资源的快速简单配置。我们的主控板除了串口一作为HFLink通信的默认端口外还预留了其他的串口。如果串口USB插拔损坏，则表示串口一的硬件损坏，此时可以转而使用其他未被占用的预留串口。 具体步骤如下： 如果使用的是control_unit_v2： 1.进入文件夹.../OpenRE/0_Project/makefile路径下，打开system_para.mk文件。 2.找到如下代码： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_v2\" select the usartx for board debug info printf : usart_interface_x,usb_slave DEBUG_PRINTF_INTERFACE ?= usart_interface_1 select the usartxfor pc communications (hf_link) :usart_interface_x,usb_slave PC_INTERFACE ?= usart_interface_1 select the usartx for remote control (hf_link) : usart_interface_x RADIO_INTERFACE ?= usart_interface_4 endif \"DEBUG_PRINTF_INTERFACE\"就是调试使用的串口号，目前是串口1。 \"PC_INTERFACE\"就是HFLink，也即上下位机通信使用的串口号，目前也是串口1。 串口USB插拔损坏，表示串口一现在无法正常使用。只需要在这里将 DEBUG_PRINTF_INTERFACE ?= usart_interface_1 PC_INTERFACE ?= usart_interface_1 修改为 DEBUG_PRINTF_INTERFACE ?= usart_interface_6 PC_INTERFACE ?= usart_interface_6 即可。 注意：串口2被SBUS占用，V2主控板上只剩下串口6空闲。 3.将USB的一端连接电脑，另一端，用我们淘宝店售卖的USB转TTL转接板接到V2主控板正面的uart6端口上。此时即可正常通信 如果使用的是control_unit_mini： 1.进入文件夹.../OpenRE/0_Project/makefile路径下，打开system_para.mk文件。 2.找到如下代码： ifeq \"$(strip $(BOARD_TYPE))\" \"control_unit_mini\" select the usartx for board debug info printf : usart_interface_x,usb_slave DEBUG_PRINTF_INTERFACE ?= usart_interface_4 select the usartxfor pc communications (hf_link) : usart_interface_x,usb_slave PC_INTERFACE ?= usart_interface_4 select the usartx for remote control (hf_link) : usart_interface_x RADIO_INTERFACE ?= usart_interface_5 endif DEBUG_PRINTF_INTERFACE就是调试使用的串口号，目前是串口4。 PC_INTERFACE就是HFLink，也即上下位机通信使用的串口号，目前是串口1。 串口USB插拔损坏，表示串口一现在无法正常使用。只需要在这里将 DEBUG_PRINTF_INTERFACE ?= usart_interface_4 PC_INTERFACE ?= usart_interface_4 修改为 DEBUG_PRINTF_INTERFACE ?= usart_interface_5 PC_INTERFACE ?= usart_interface_5 即可。 3.将USB的一端连接电脑，另一端，用我们淘宝店售卖的USB转TTL转接板接到Mini主控板正面的usart4端口上。此时即可正常通信。 Copyright © handsfree.org.cn 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-04-24 20:27:52 "}}